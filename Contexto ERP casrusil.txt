# DocumentaciÃ³n TÃ©cnica Completa - CASRUSIL-SII-ERP-AI

Para que cualquier asistente de IA pueda implementar/mantener este proyecto sin errores, necesitas agregar estos elementos crÃ­ticos a tu contexto:

---

## ğŸ“‹ ÃNDICE DE DOCUMENTACIÃ“N NECESARIA

### 1. **Mapa de Estado del Proyecto (Project State Map)**

Crea: `PROJECT_STATE.md`

```markdown
# Estado Actual del Proyecto SII-ERP-AI

## âœ… IMPLEMENTADO (No tocar sin razÃ³n explÃ­cita)

### MÃ³dulo: shared (Kernel)
- âœ… `CompanyContext.java` - ScopedValue multi-tenant (FUNCIONAL - NO MODIFICAR)
- âœ… `VirtualThreadConfig.java` - ConfiguraciÃ³n Virtual Threads (CRÃTICO)
- âœ… `SpringEventPublisher.java` - Event bus (TESTEADO)
- âœ… `DomainEvent.java` - Interface base eventos

### MÃ³dulo: integration_sii
- âœ… `XmlDsigSigner.java` - Firma digital XMLDSig (CRÃTICO - Certificado por pruebas SII)
- âœ… `Pkcs12Handler.java` - Manejo certificados .p12 (FUNCIONAL)
- âœ… `SiiAuthSoapClient.java` - Handshake SII (PROBADO en producciÃ³n)
- âœ… `SiiRcvSoapClient.java` - Descarga RCV (FUNCIONAL)
- âœ… `RcvXmlParser.java` - Parser XML del SII (VALIDADO con datos reales)
- âš ï¸ `SiiOperationsController.java` - Controller de pruebas (BETA - puede mejorar logging)

### MÃ³dulo: invoicing
- âœ… `InvoiceEntity.java` - Entidad JPA (TABLA CREADA en DB)
- âœ… `InvoiceJpaRepository.java` - Repository (FUNCIONAL)
- âœ… `InvoiceController.java` - REST API (TESTEADO con Postman)
- âš ï¸ `DtesDownloadedListener.java` - Event listener (EN DESARROLLO)

### MÃ³dulo: accounting
- ğŸš§ `AccountingEntry.java` - Asiento contable (ESTRUCTURA DEFINIDA - sin implementar)
- ğŸš§ `InvoiceAccountingListener.java` - Auto-generaciÃ³n asientos (PENDIENTE PRUEBAS)

### MÃ³dulo: ai_assistant
- âœ… `SearchInvoicesTool.java` - Tool para LLM (FUNCIONAL)
- âœ… `AiConfig.java` - ConfiguraciÃ³n LangChain4j (PROBADO con GPT-4)
- âš ï¸ `AiAssistantController.java` - Chat endpoint (FUNCIONAL - falta manejo errores)

### MÃ³dulo: sso
- ğŸš§ `SecurityFilter.java` - JWT + ScopedValue (ESTRUCTURA DEFINIDA - sin tests)
- ğŸš§ `JwtTokenProvider.java` - GeneraciÃ³n tokens (PENDIENTE)

---

## ğŸš« NO IMPLEMENTADO (Espacio para futuras features)

### MÃ³dulo: integration_sii
- âŒ `DteSenderService.java` - EmisiÃ³n de facturas (DISEÃ‘ADO pero no codificado)
- âŒ `TokenRefreshScheduler.java` - RenovaciÃ³n automÃ¡tica tokens

### MÃ³dulo: accounting
- âŒ `F29CalculatorService.java` - CÃ¡lculo F29 (SOLO DISEÃ‘O)
- âŒ `PeriodClosingService.java` - Cierre contable mensual

### MÃ³dulo: ai_assistant
- âŒ `PgVectorAdapter.java` - RAG con embeddings (PLANIFICADO)
- âŒ `CalculateF29Tool.java` - Tool para F29

---

## âš ï¸ DEUDA TÃ‰CNICA CONOCIDA

1. **InvoiceController.mapToEntity()**: Mapper manual. PENDIENTE: Migrar a MapStruct.
2. **XmlDsigSigner**: Hardcoded ISO-8859-1. TODO: Parametrizar encoding por certificadora.
3. **Error Handling Global**: Falta `@ControllerAdvice` unificado.
4. **Tests de IntegraciÃ³n**: Solo existen tests unitarios. FALTA: Testcontainers.

---

## ğŸ” CÃ“DIGO CRÃTICO (Requiere aprobaciÃ³n senior antes de modificar)

### Archivos que SI se rompen, el sistema colapsa:
1. `CompanyContext.java` (Multi-tenant core)
2. `XmlDsigSigner.java` (SII rechazarÃ¡ requests)
3. `SecurityFilter.java` (Brecha de seguridad)
4. `VirtualThreadConfig.java` (Performance crÃ­tica)

### Regla de Oro:
Si vas a refactorizar estos archivos:
1. Crea un branch separado
2. Escribe tests PRIMERO
3. Documenta cada cambio en CHANGELOG.md

---

## ğŸ“¦ DEPENDENCIAS EXTERNAS VERIFICADAS

```gradle
// ESTAS VERSIONES ESTÃN PROBADAS Y FUNCIONAN
implementation("org.apache.santuario:xmlsec:3.0.4") // âœ… Compatible SII
implementation("dev.langchain4j:langchain4j-spring-boot-starter:0.35.0") // âœ… Stable
implementation("org.springframework.boot:spring-boot-starter-web:3.4.0") // âœ… Java 25 ready
```

### âš ï¸ Versiones ProblemÃ¡ticas (NO USAR):
- âŒ `xmlsec:2.x.x` - Bug con namespaces del SII
- âŒ `langchain4j:0.30.x` - Incompatible con Tools
```

---

### 2. **Diccionario de Decisiones ArquitectÃ³nicas (ADRs)**

Crea: `docs/decisions/`

**ADR-001-virtual-threads.md**:
```markdown
# ADR 001: Uso de Virtual Threads (Java 25)

## Estado
ACEPTADO - Implementado en VirtualThreadConfig.java

## Contexto
El sistema maneja operaciones I/O bloqueantes (SOAP calls al SII) que en un modelo tradicional consumirÃ­an threads del OS.

## DecisiÃ³n
Usar `Executors.newVirtualThreadPerTaskExecutor()` para:
- HTTP requests (Tomcat)
- Event listeners (@Async)
- Schedulers

## Consecuencias
âœ… Positivas:
- 10,000+ requests concurrentes sin colapso
- SimplificaciÃ³n de cÃ³digo async (no callbacks)
- ScopedValue se propaga automÃ¡ticamente

âš ï¸ Negativas:
- Requiere Java 25+ (no portable a Java 17)
- Debugging mÃ¡s complejo (stack traces virtuales)

## ValidaciÃ³n
Probado con Apache JMeter: 5000 requests/s sin degradaciÃ³n.

## Alternativas Rechazadas
1. âŒ ThreadPoolTaskExecutor: RequerÃ­a TaskDecorator manual
2. âŒ Reactor/WebFlux: Complejidad innecesaria para este caso
```

---

### 3. **Glosario del Dominio (Ubiquitous Language)**

Crea: `docs/GLOSSARY.md`

```markdown
# Glosario del Dominio - TerminologÃ­a Fiscal Chilena

## Conceptos del SII
- **DTE**: Documento Tributario ElectrÃ³nico (factura digital)
- **Folio**: NÃºmero Ãºnico consecutivo de un DTE
- **RCV**: Registro de Compras y Ventas (sistema del SII)
- **Semilla**: Token temporal generado por el SII para inicio de sesiÃ³n
- **GetToken**: Endpoint SOAP que autentica con semilla firmada

## Tipos de DTE (tipoDte)
```java
public enum TipoDte {
    FACTURA_AFECTA(33),       // Factura con IVA
    FACTURA_EXENTA(34),       // Factura sin IVA
    BOLETA_AFECTA(39),        // Boleta con IVA
    BOLETA_EXENTA(41),        // Boleta sin IVA
    NOTA_CREDITO(61),         // AnulaciÃ³n/descuento
    NOTA_DEBITO(56)           // Cargo adicional
}
```

## Conceptos Contables
- **Asiento Contable**: Registro Debe/Haber que afecta al menos 2 cuentas
- **Plan de Cuentas**: Estructura jerÃ¡rquica de cuentas (Ej: "1-10-50" = Activos > Corrientes > Caja)
- **Libro Diario**: Registro cronolÃ³gico de asientos
- **F29**: Formulario de declaraciÃ³n mensual de IVA

## Conceptos TÃ©cnicos
- **ScopedValue**: Mecanismo Java 25 para contexto inmutable (reemplaza ThreadLocal)
- **XMLDSig**: EstÃ¡ndar de firma digital XML (usado por el SII)
- **PKCS#12**: Formato de certificado digital (.p12 / .pfx)
- **CanonicalizaciÃ³n**: NormalizaciÃ³n de XML antes de firmar
```

---

### 4. **Reglas de Negocio CrÃ­ticas**

Crea: `docs/BUSINESS_RULES.md`

```markdown
# Reglas de Negocio CrÃ­ticas

## R1: Multi-Tenancy Estricto
**NUNCA mostrar datos de una empresa a otra**

```java
// âœ… CORRECTO - Siempre filtrar por companyId
UUID companyId = CompanyContext.requireCompanyId().value();
repository.findByCompanyId(companyId);

// âŒ INCORRECTO - Query sin filtro de empresa
repository.findAll(); // VULNERABILIDAD
```

**Test Obligatorio**: Cada query a DB debe tener test que valide aislamiento.

---

## R2: Idempotencia de SincronizaciÃ³n
**La sincronizaciÃ³n con el SII debe ser idempotente**

```java
// âœ… IMPLEMENTADO en InvoiceController
boolean exists = repository.existsByCompanyIdAndRutEmisorAndTipoDteAndFolio(...);
if (!exists) { save(); }
```

**RazÃ³n**: El SII puede devolver duplicados. El usuario puede hacer clic 5 veces en "Sincronizar".

---

## R3: Encoding del SII
**Todo XML enviado al SII DEBE usar ISO-8859-1**

```java
// âœ… CORRECTO
String xml = """
    <?xml version="1.0" encoding="ISO-8859-1"?>
    ...
""";

// âŒ INCORRECTO
String xml = """
    <?xml version="1.0" encoding="UTF-8"?>  // SII rechaza
    ...
""";
```

**ValidaciÃ³n**: XmlDsigSigner.java lÃ­nea 42 fuerza este encoding.

---

## R4: Asientos Contables Balanceados
**Debe = Haber (Siempre)**

```java
// âœ… CORRECTO
entry.addDebit("1-10-10", 1000);  // Caja
entry.addCredit("4-10-05", 1000); // Ingresos
// Total Debe = 1000, Total Haber = 1000 âœ…

// âŒ INCORRECTO
entry.addDebit("1-10-10", 1000);
entry.addCredit("4-10-05", 900);  // ERROR: Descuadre de $100
```

**ValidaciÃ³n**: `DoubleEntryValidator.java` debe lanzar exception si descuadra.

---

## R5: Tokens del SII Caducan en 1 Hora
**SIEMPRE verificar vigencia antes de usar token**

```java
// âœ… IMPLEMENTADO en RedisTokenCache
if (token.expiresAt().isBefore(Instant.now())) {
    token = authService.refreshToken();
}
```

**Estrategia**: Cachear en Redis con TTL de 55 minutos (margen de seguridad).
```

---

### 5. **GuÃ­a de Troubleshooting**

Crea: `docs/TROUBLESHOOTING.md`

```markdown
# GuÃ­a de ResoluciÃ³n de Problemas

## Error: "Invalid Signature" del SII

### SÃ­ntomas
```
SiiAuthenticationException: El SII rechazÃ³ la firma digital
```

### DiagnÃ³stico
1. Verificar encoding:
```bash
curl http://localhost:8080/api/v1/sii/ops/check-auth
# Si falla, revisar XmlDsigSigner lÃ­nea 42
```

2. Validar certificado:
```java
// En Pkcs12Handler, agregar temporalmente:
System.out.println("Cert Valid From: " + cert.getNotBefore());
System.out.println("Cert Valid Until: " + cert.getNotAfter());
```

3. Verificar canonicalizaciÃ³n:
```java
// El XML antes de firmar NO debe tener pretty-print
// âŒ MAL: <tag>\n  <subtag>...
// âœ… BIEN: <tag><subtag>...
```

### SoluciÃ³n ComÃºn
El 90% de los casos es encoding UTF-8 vs ISO-8859-1.
**Fix**: Revisar lÃ­nea 42 de XmlDsigSigner.java

---

## Error: CompanyContext es null

### SÃ­ntomas
```
IllegalStateException: No company context found
```

### DiagnÃ³stico
1. Verificar JWT:
```bash
# Decodificar token en jwt.io
# Debe contener: { "companyId": "uuid-aqui" }
```

2. Verificar SecurityFilter:
```java
// Agregar log temporal:
log.debug("CompanyId set: {}", companyId); // Antes del runInCompanyContext
```

### SoluciÃ³n
- Si JWT no tiene companyId: Revisar JwtTokenProvider lÃ­nea X
- Si tiene pero falla: Verificar que SecurityFilter se ejecuta ANTES del controller

---

## Error: Virtual Thread no propaga contexto

### SÃ­ntomas
```
@Async Listener recibe companyId=null
```

### DiagnÃ³stico
```java
// En el Listener, agregar:
log.debug("Thread: {}", Thread.currentThread());
// Si NO dice "VirtualThread", el problema estÃ¡ en VirtualThreadConfig
```

### SoluciÃ³n
Verificar que VirtualThreadConfig.java tenga:
```java
@Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
```

---

## Performance: Queries lentas

### DiagnÃ³stico
```yaml
# Agregar en application-dev.yml
spring:
  jpa:
    properties:
      hibernate:
        show_sql: true
        format_sql: true
```

### Ãndices Requeridos
```sql
-- CRÃTICO para performance
CREATE INDEX idx_invoices_company_date 
ON invoicing.invoices(company_id, fecha_emision);

CREATE INDEX idx_invoices_lookup 
ON invoicing.invoices(company_id, rut_emisor, tipo_dte, folio);
```
```

---

### 6. **Scripts de Migraciones SQL Documentadas**

Crea: `src/main/resources/db/migration/README.md`

```markdown
# Migraciones de Base de Datos

## Orden de EjecuciÃ³n (Flyway)

### V1__create_schemas.sql
```sql
-- Crea los 5 esquemas lÃ³gicos
-- CRÃTICO: No modificar nombres, estÃ¡n referenciados en 100+ lugares
CREATE SCHEMA IF NOT EXISTS sso;
CREATE SCHEMA IF NOT EXISTS sii;
CREATE SCHEMA IF NOT EXISTS invoicing;
CREATE SCHEMA IF NOT EXISTS accounting;
CREATE SCHEMA IF NOT EXISTS ai;
```

### V2__create_sso_tables.sql
```sql
-- Tabla users: Almacena credenciales
-- âš ï¸ NUNCA guardar passwords en texto plano
-- âœ… SIEMPRE usar BCryptPasswordEncoder

CREATE TABLE sso.users (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    email VARCHAR(255) UNIQUE NOT NULL,
    password_hash VARCHAR(255) NOT NULL, -- BCrypt
    company_id UUID NOT NULL REFERENCES sso.companies(id),
    role VARCHAR(50) NOT NULL,
    active BOOLEAN DEFAULT true,
    created_at TIMESTAMP DEFAULT NOW()
);

-- Ãndice CRÃTICO para login
CREATE INDEX idx_users_email ON sso.users(email);
```

### V4__create_invoicing_tables.sql
```sql
-- âš ï¸ CONSTRAINT ÃšNICO para evitar duplicados
CREATE TABLE invoicing.invoices (
    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    company_id UUID NOT NULL,
    tipo_dte INTEGER NOT NULL,
    folio BIGINT NOT NULL,
    rut_emisor VARCHAR(12) NOT NULL,
    -- ... otros campos
    CONSTRAINT uk_invoice_duplicity 
        UNIQUE (company_id, rut_emisor, tipo_dte, folio)
);

-- Ãndice para queries del dashboard
CREATE INDEX idx_invoices_dashboard 
ON invoicing.invoices(company_id, fecha_emision DESC);
```

## Rollback Manual

Si Flyway falla, usar estos comandos:

```sql
-- Ver estado
SELECT * FROM flyway_schema_history ORDER BY installed_rank DESC;

-- Rollback V4 (Ejemplo)
DROP TABLE IF EXISTS invoicing.invoices CASCADE;
DELETE FROM flyway_schema_history WHERE version = '4';
```
```

---

### 7. **Matriz de Compatibilidad de Dependencias**

Crea: `docs/DEPENDENCIES.md`

```markdown
# Matriz de Compatibilidad

## âœ… ConfiguraciÃ³n PROBADA (No cambiar sin tests)

| Dependencia | VersiÃ³n | Java | Notas |
|------------|---------|------|-------|
| Spring Boot | 3.4.0 | 25 | âœ… Soporta --enable-preview |
| PostgreSQL Driver | 42.7.4 | 25 | âœ… Compatible pgvector |
| Apache Santuario | 3.0.4 | 21+ | âœ… XMLDSig funcional con SII |
| LangChain4j | 0.35.0 | 17+ | âœ… Tools estables |
| MapStruct | 1.6.2 | 21+ | âš ï¸ Requiere annotation processor |

## âŒ Versiones INCOMPATIBLES

| Dependencia | VersiÃ³n | Problema |
|------------|---------|----------|
| xmlsec | 2.3.x | Bug con namespaces del SII Chile |
| langchain4j | 0.29.x | Tools no reconocidas |
| hibernate | 6.2.x | Conflicto con Virtual Threads |

## Comando de VerificaciÃ³n
```bash
./gradlew dependencies --configuration runtimeClasspath | grep -i "version conflict"
```
```

---

### 8. **Plantilla de Issues/PRs**

Crea: `.github/PULL_REQUEST_TEMPLATE.md`

```markdown
## DescripciÃ³n del Cambio
<!-- Â¿QuÃ© problema resuelve este PR? -->

## Tipo de Cambio
- [ ] ğŸ› Bug fix (cambio que corrige un issue)
- [ ] âœ¨ Nueva feature (cambio que agrega funcionalidad)
- [ ] ğŸ’¥ Breaking change (cambio que rompe compatibilidad)
- [ ] ğŸ”§ Refactor (cambio que no afecta comportamiento)

## âš ï¸ MÃ³dulos Afectados
<!-- Marca los mÃ³dulos que tocaste -->
- [ ] shared (Kernel)
- [ ] integration_sii
- [ ] invoicing
- [ ] accounting
- [ ] ai_assistant
- [ ] sso

## Checklist de Seguridad
- [ ] âœ… Queries filtran por `companyId` (multi-tenant)
- [ ] âœ… No hay hardcoded credentials
- [ ] âœ… Input validation implementada
- [ ] âœ… CompanyContext se propaga correctamente

## Tests
- [ ] âœ… Tests unitarios agregados/actualizados
- [ ] âœ… Tests de integraciÃ³n pasan
- [ ] âœ… Probado manualmente con certificado SII real

## DocumentaciÃ³n
- [ ] âœ… PROJECT_STATE.md actualizado
- [ ] âœ… CHANGELOG.md actualizado
- [ ] âœ… Javadoc agregado si es cÃ³digo pÃºblico

## RevisiÃ³n de CÃ³digo CrÃ­tico
<!-- Si modificaste estos archivos, DEBES justificarlo -->
- [ ] âš ï¸ CompanyContext.java - RazÃ³n: ___________
- [ ] âš ï¸ XmlDsigSigner.java - RazÃ³n: ___________
- [ ] âš ï¸ SecurityFilter.java - RazÃ³n: ___________
```

---

### 9. **Endpoints y Contracts (OpenAPI Completo)**

Crea: `docs/API_CONTRACTS.md`

```markdown
# Contratos de API - DocumentaciÃ³n Completa

## Base URL
```
Development: http://localhost:8080
Production: https://api.tuempresa.com
```

## AutenticaciÃ³n
Todos los endpoints (excepto `/auth/login`) requieren:
```http
Authorization: Bearer <JWT_TOKEN>
```

El token JWT DEBE contener:
```json
{
  "sub": "user-uuid",
  "companyId": "company-uuid",
  "exp": 1735689600
}
```

---

## Endpoints Implementados

### 1. SII Operations

#### POST /api/v1/sii/ops/fetch-rcv
**PropÃ³sito**: Descarga facturas del SII en tiempo real

**Request**:
```http
POST /api/v1/sii/ops/fetch-rcv?rut=76123456-7&periodo=202512
Authorization: Bearer xxx
```

**Response 200**:
```json
[
  {
    "tipoDte": 33,
    "folio": 12345,
    "rutEmisor": "96999888-0",
    "razonSocialEmisor": "AMAZON WEB SERVICES",
    "fechaEmision": "2025-12-01",
    "montoTotal": { "amount": 150000 },
    "montoIva": { "amount": 23950 },
    "montoNeto": { "amount": 126050 },
    "estado": "REGISTRO"
  }
]
```

**Errores Posibles**:
```json
// 401 Unauthorized - Token invÃ¡lido
{
  "error": "INVALID_TOKEN",
  "message": "JWT expired or malformed"
}

// 500 Internal Server Error - SII no responde
{
  "error": "SII_CONNECTION_ERROR",
  "message": "Timeout connecting to SII services"
}
```

---

### 2. Invoicing

#### GET /api/v1/invoices
**PropÃ³sito**: Lista facturas guardadas en DB local

**Request**:
```http
GET /api/v1/invoices?month=2025-12
Authorization: Bearer xxx
```

**Response 200**:
```json
[
  {
    "id": "uuid-123",
    "companyId": "uuid-company",
    "tipoDte": 33,
    "folio": 12345,
    "rutEmisor": "96999888-0",
    "razonSocialEmisor": "AMAZON WEB SERVICES",
    "fechaEmision": "2025-12-01",
    "montoTotal": 150000,
    "origen": "SII_SYNC",
    "createdAt": "2025-12-02T14:30:00Z"
  }
]
```

---

### 3. AI Assistant

#### POST /api/v1/ai/chat
**PropÃ³sito**: Chat con asistente financiero

**Request**:
```json
{
  "message": "Â¿CuÃ¡nto gastamos con AWS el mes pasado?"
}
```

**Response 200**:
```json
{
  "answer": "En diciembre de 2025, la empresa gastÃ³ $150.000 con Amazon Web Services (AWS), correspondiente a 1 factura emitida el 01/12/2025."
}
```

**Flujo Interno**:
```
1. Controller recibe mensaje
2. LangChain4j analiza intenciÃ³n
3. Ejecuta SearchInvoicesTool("2025-12-01", "2025-12-31")
4. Tool consulta PostgreSQL con companyId del contexto
5. LLM genera respuesta en lenguaje natural
6. Retorna JSON
```
```

---

### 10. **Variables de Entorno Documentadas**

Crea: `docs/ENVIRONMENT.md`

```markdown
# Variables de Entorno

## Desarrollo Local

Crea un archivo `.env.local` (Git ignored):

```bash
# Database
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/sii_erp
SPRING_DATASOURCE_USERNAME=postgres
SPRING_DATASOURCE_PASSWORD=tu_password_aqui

# Redis
SPRING_DATA_REDIS_HOST=localhost
SPRING_DATA_REDIS_PORT=6379

# OpenAI (IA)
OPENAI_API_KEY=sk-tu-api-key-real-aqui

# SII Endpoints
SII_URL_AUTH=https://maullin.sii.cl/DTEWS  # CertificaciÃ³n
# SII_URL_AUTH=https://palena.sii.cl/DTEWS  # ProducciÃ³n

# Certificado de Prueba (Solo Dev)
SII_TEST_CERT_PATH=/path/to/certificado_prueba.p12
SII_TEST_CERT_PASSWORD=password123
```

## ProducciÃ³n (Docker/Kubernetes)

```yaml
# docker-compose.yml
environment:
  - SPRING_PROFILES_ACTIVE=prod
  - SPRING_DATASOURCE_URL=${DB_URL}  # Inyectado por Secrets Manager
  - OPENAI_API_KEY=${OPENAI_KEY}     # Inyectado por Vault
  - SII_URL_AUTH=https://palena.sii.cl/DTEWS  # SIEMPRE producciÃ³n
```

## Variables CrÃ­ticas (NUNCA commitear)

| Variable | DescripciÃ³n | Default Dev | Prod Obligatorio |
|----------|-------------|-------------|------------------|
| OPENAI_API_KEY | API Key OpenAI | (ninguno) | âœ… Requerido |
| SPRING_DATASOURCE_PASSWORD | Password DB | postgres | âœ… Desde Secrets |
| JWT_SECRET | Secret para firmar JWT | (generado) | âœ… Vault |
```

---

### 11. **Diagrama de Flujo de Eventos**

Crea: `docs/diagrams/event-flow.mermaid`

```mermaid
graph TD
    A[RcvSyncScheduler Cron] -->|Ejecuta cada noche| B[SiiAuthenticationService]
    B -->|Obtiene Token| C[SiiRcvSoapClient]
    C -->|SOAP Request| D[SII Palena]
    D -->|XML Response| E[RcvXmlParser]
    E -->|Parsea| F[List RcvInvoiceSummary]
    F -->|Guarda| G[InvoiceJpaRepository]
    G -->|Persiste| H[PostgreSQL invoicing.invoices]
    G -->|Publica| I[InvoiceReceivedEvent]
    
    I -->|Event Bus Spring| J[InvoiceAccountingListener]
    I -->|Event Bus Spring| K[AI Index Listener]
    
    J -->|Auto-genera| L[AccountingEntry]
    L -->|Guarda| M[PostgreSQL accounting.entries]
    
    K -->|Indexa| N[PgVector Embeddings]
    
    style D fill:#f96,stroke:#333,stroke-width:4px
    style H fill:#9f6,stroke:#333,stroke-width:2px
    style M fill:#9f6,stroke:#333,stroke-width:2px
```

---

### 12. **Comandos de Desarrollo Frecuentes**

Crea: `docs/DEV_COMMANDS.md`

```bash
# ===== BUILD & RUN =====

# Compilar con Java 25 preview features
./gradlew build --enable-preview

# Correr en modo desarrollo (con hot-reload)
./gradlew bootRun --args='--spring.profiles.active=dev'

# Correr con Docker
docker-compose up --build

# ===== TESTING =====

# Tests unitarios
./gradlew test

# Tests de integraciÃ³n (requiere Testcontainers)
./gradlew integrationTest

# Test especÃ­fico
./gradlew test --tests "XmlDsigSignerTest"

# ===== DATABASE =====

# Aplicar migraciones Flyway
./gradlew flywayMigrate

# Rollback Ãºltima migraciÃ³n
./gradlew flywayUndo

# Ver estado migraciones
./gradlew flywayInfo

# Conectar a PostgreSQL local
psql -U postgres -d sii_erp

# Ver esquemas
\dn

# Ver tablas de un esquema
\dt invoicing.*

# ===== DEBUGGING =====

# Ver logs en tiempo real
docker-compose logs -f app

# Ver queries SQL ejecutadas
tail -f logs/spring.log | grep "Hibernate:"

# Limpiar cachÃ© Redis
redis-cli FLUSHALL

# ===== CERTIFICADOS SII =====

# Ver contenido de un .p12
keytool -list -v -keystore certificado.p12 -storepass password

# Extraer certificado pÃºblico
openssl pkcs12 -in certificado.p12 -nokeys -out cert.pem

# Validar fechas
openssl x509 -in cert.pem -noout -dates

# ===== PERFORMANCE =====

# Profile de performance (CPU)
java -agentpath:/path/to/async-profiler.so -jar app.jar

# Memory dump si hay leak
jmap -dump:live,format=b,file=heap.bin <PID>
```

---

## ğŸ¯ CHECKLIST FINAL PARA ASISTENTES DE IA

Cuando un asistente de IA (Claude/Gemini/ChatGPT) vaya a modificar cÃ³digo, debe:

### Antes de Tocar CÃ³digo:

```markdown
- [ ] Leer `PROJECT_STATE.md` completo
- [ ] Identificar si el archivo a modificar estÃ¡ en la secciÃ³n "âœ… IMPLEMENTADO"
- [ ] Si estÃ¡ implementado, leer `docs/decisions/ADR-XXX.md` relacionado
- [ ] Verificar en `GLOSSARY.md` si usa terminologÃ­a especÃ­fica del dominio
- [ ] Revisar `BUSINESS_RULES.md` si toca lÃ³gica de negocio
- [ ] Buscar en `TROUBLESHOOTING.md` si el problema ya tiene soluciÃ³n conocida
```

### Al Implementar:

```markdown
- [ ] NO borrar cÃ³digo existente sin entender su propÃ³sito
- [ ] NO cambiar nombres de clases/mÃ©todos sin buscar referencias
- [ ] Mantener encoding ISO-8859-1 en comunicaciÃ³n con SII
- [ ] SIEMPRE filtrar queries por `CompanyContext.requireCompanyId()`
- [ ] Usar ScopedValue, NUNCA ThreadLocal
- [ ] Mantener patrÃ³n

Event-Driven (no llamadas directas entre mÃ³dulos)
```

### Al Terminar:

```markdown
- [ ] Actualizar `PROJECT_STATE.md` con cambios
- [ ] Agregar entry en `CHANGELOG.md`
- [ ] Documentar en JavaDoc si es cÃ³digo pÃºblico
- [ ] Escribir test que valide el cambio
- [ ] Ejecutar `./gradlew test` localmente
```

---

## ğŸ“ ARCHIVO FINAL: `AI_ASSISTANT_INSTRUCTIONS.md`

Este es el archivo CRÃTICO que resume todo:

```markdown
# Instrucciones para Asistentes de IA

## ğŸš¨ REGLAS DE ORO (NUNCA VIOLAR)

1. **Leer SIEMPRE `PROJECT_STATE.md` antes de modificar cÃ³digo**
2. **Archivos con âœ… = FUNCIONAL, modificar solo si hay bug crÃ­tico**
3. **Archivos con ğŸš§ = EN DESARROLLO, puedes completar**
4. **Archivos con âŒ = NO EXISTE, puedes crear desde cero**
5. **CÃ³digo marcado como "CRÃTICO" = Pedir aprobaciÃ³n senior antes de tocar**

## ğŸ” Proceso de AnÃ¡lisis Antes de Codificar

```python
def antes_de_modificar_archivo(filepath):
    # Paso 1: Verificar estado
    estado = buscar_en("PROJECT_STATE.md", filepath)
    
    if estado == "IMPLEMENTADO":
        print("âš ï¸ CUIDADO: CÃ³digo funcional")
        leer("docs/decisions/ADR-relacionado.md")
        preguntar_usuario("Â¿Seguro que hay que modificar esto?")
    
    # Paso 2: Verificar si hay regla de negocio
    if "Service" in filepath or "Controller" in filepath:
        leer("docs/BUSINESS_RULES.md")
    
    # Paso 3: Verificar dependencias
    if modificando_dependencias():
        leer("docs/DEPENDENCIES.md")
        verificar_compatibilidad()
    
    # Paso 4: Buscar problemas conocidos
    buscar_en("docs/TROUBLESHOOTING.md", error_usuario)
```

## ğŸ› ï¸ Plantillas de CÃ³digo

### Al Crear un Nuevo Service:

```java
package com.tuempresa.erp.modules.MODULO.domain.service;

import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

@Service
public class MiNuevoService {
    
    private static final Logger log = LoggerFactory.getLogger(MiNuevoService.class);
    
    public void miMetodo() {
        // âœ… SIEMPRE obtener contexto
        var companyId = CompanyContext.requireCompanyId();
        
        log.debug("Ejecutando operaciÃ³n para empresa: {}", companyId);
        
        // Tu lÃ³gica aquÃ­
    }
}
```

### Al Crear un Nuevo Controller:

```java
@RestController
@RequestMapping("/api/v1/MODULO")
public class MiController {
    
    @GetMapping
    public ResponseEntity<?> listar() {
        // âœ… Contexto automÃ¡tico por SecurityFilter
        var companyId = CompanyContext.requireCompanyId();
        
        // âœ… SIEMPRE filtrar por empresa
        var data = repository.findByCompanyId(companyId.value());
        
        return ResponseEntity.ok(data);
    }
}
```

## ğŸ“š Archivos de Referencia por Tipo de Tarea

| Tarea | Leer Primero |
|-------|--------------|
| Agregar endpoint REST | `docs/API_CONTRACTS.md` |
| Modificar autenticaciÃ³n SII | `docs/decisions/ADR-002-sii-soap.md` |
| Cambiar lÃ³gica contable | `docs/BUSINESS_RULES.md` (SecciÃ³n R4) |
| Agregar herramienta IA | `docs/AI_TOOLS.md` |
| Debugging | `docs/TROUBLESHOOTING.md` |
| Agregar dependencia | `docs/DEPENDENCIES.md` |

## âš ï¸ SeÃ±ales de Alerta

Si encuentras esto en el cÃ³digo, DETENTE y pregunta:

```java
// ğŸš© ThreadLocal en lugar de ScopedValue
private static final ThreadLocal<CompanyId> CONTEXT = new ThreadLocal<>();

// ğŸš© Query sin filtro de empresa
repository.findAll(); // Vulnerabilidad multi-tenant

// ğŸš© Encoding UTF-8 para el SII
"<?xml version=\"1.0\" encoding=\"UTF-8\"?>"  // Debe ser ISO-8859-1

// ğŸš© Token hardcodeado
String token = "ABC123...";  // Debe venir de Redis cache

// ğŸš© Certificado en texto plano
String password = "mipassword123";  // Debe estar encriptado
```

## ğŸ¯ Casos de Uso Comunes

### "Usuario reporta: El SII rechaza la firma"
1. Leer `TROUBLESHOOTING.md` secciÃ³n "Invalid Signature"
2. Verificar XmlDsigSigner.java lÃ­nea 42 (encoding)
3. NO modificar algoritmo de firma sin consultar

### "Necesito agregar nuevo tipo de reporte contable"
1. Leer `BUSINESS_RULES.md` secciÃ³n contabilidad
2. Verificar si `accounting` module estÃ¡ en estado âœ… o ğŸš§
3. Si âœ…: Extender, no reemplazar
4. Si ğŸš§: Completar implementaciÃ³n existente

### "La IA no puede acceder a nuevos datos"
1. Crear nueva `@Tool` en `ai_assistant/application/tools/`
2. Registrar en `AiConfig.java`
3. Documentar en `docs/AI_TOOLS.md`
4. Probar con prompt: "Dame [tipo de dato]"

## ğŸ“ Template de Commit

```
<tipo>(<mÃ³dulo>): <descripciÃ³n corta>

<descripciÃ³n detallada opcional>

Refs: #123 (si hay issue)
Docs: Actualizado PROJECT_STATE.md lÃ­nea X
Tests: âœ… XxxTest agregado

BREAKING CHANGE: <si aplica>
```

Tipos: feat, fix, refactor, docs, test, chore
```

---

Con esta documentaciÃ³n completa, cualquier asistente de IA podrÃ¡:

âœ… Entender el estado actual sin alucinar cÃ³digo inexistente  
âœ… Modificar solo lo necesario sin romper lo funcional  
âœ… Seguir las convenciones arquitectÃ³nicas  
âœ… Validar que sus cambios respetan las reglas de negocio  
âœ… Documentar apropiadamente lo que hace  






1. Identidad del Proyecto y Objetivo
Nombre: CASRUSIL-SII-ERP-AI MisiÃ³n: Construir un ERP contable robusto para Chile, con integraciÃ³n nativa al Servicio de Impuestos Internos (SII) y capacidades de Inteligencia Artificial (RAG/Tools) para asistencia financiera. Nivel de IngenierÃ­a: Enterprise / Architect Level. Estado: DefiniciÃ³n ArquitectÃ³nica Completa / Fase de ImplementaciÃ³n Inicial.

2. Stack TecnolÃ³gico (Restricciones Duras)
La IA debe generar cÃ³digo respetando estrictamente estas versiones y tecnologÃ­as:


Lenguaje: Java 25 (Preview Features Enabled).



Concurrencia: Virtual Threads (Project Loom) exclusivamente. Prohibido usar ThreadPoolExecutor manuales o @Async legacy.



GestiÃ³n de Dependencias: Gradle Kotlin DSL (build.gradle.kts).


Framework: Spring Boot 3.4.0+.


Base de Datos: PostgreSQL 17 + ExtensiÃ³n pgvector.


CachÃ©: Redis (Alpine).


IA Framework: LangChain4j 0.35.0.


IntegraciÃ³n SII: SOAP nativo con java.net.http.HttpClient (Java 11+) y firma XMLDSig con Apache Santuario.


3. Arquitectura del Sistema
El sistema es un Monolito Modular diseÃ±ado para ser separado en microservicios a futuro si es necesario.

3.1 Patrones Core
Event-Driven: Los mÃ³dulos se comunican mediante DomainEvents (Spring Events). Desacoplamiento total.



Multi-tenancy Seguro: El contexto de la empresa (CompanyId) se maneja exclusivamente con ScopedValue (Java 25), NO con ThreadLocal.


Hexagonal (Ports & Adapters): Cada mÃ³dulo tiene domain, application (puertos), e infrastructure (adaptadores).


3.2 Estructura de MÃ³dulos (Bounded Contexts)

shared (Kernel): Utilidades, ConfiguraciÃ³n Base, Event Publisher, Security Context (ScopedValue).


sso: GestiÃ³n de Usuarios, Empresas y AutenticaciÃ³n JWT.

integration_sii: Adaptador "Sucio" Legacy. Maneja SOAP, Certificados .p12, Firmas XML y Handshake con el SII.

invoicing: GestiÃ³n de DTEs (Facturas). Persistencia, Parsing XML, GeneraciÃ³n PDF.

accounting: LÃ³gica contable pura. Libros diario/mayor, cÃ¡lculo F29. Reacciona a eventos de invoicing.

ai_assistant: Orquestador de LLM. Expone Tools que consultan otros mÃ³dulos.

4. Reglas de ImplementaciÃ³n para la IA
Regla #1: PropagaciÃ³n de Contexto (ScopedValue)
Cualquier ejecuciÃ³n asÃ­ncrona o Listener debe garantizar que el CompanyContext estÃ© disponible. PatrÃ³n a usar:

Java

// NO USAR ThreadLocal. USAR ScopedValue de Java 25:
CompanyContext.runInCompanyContext(companyId, userId, () -> {
    // LÃ³gica de negocio
});
Referencia: com.tuempresa.erp.shared.infrastructure.context.CompanyContext.

Regla #2: Clientes SOAP & Virtual Threads
No usar librerÃ­as SOAP bloqueantes antiguas (Axis/JAX-WS pesado). Usar java.net.http.HttpClient en modo sÃ­ncrono. Al correr sobre Virtual Threads, el bloqueo es virtual y no consume recursos del OS. Referencia: SiiAuthSoapClient.java.



Regla #3: Firma Digital (CriptografÃ­a)
La firma XML debe respetar la canonicalizaciÃ³n y los namespaces del SII estrictamente. Referencia: XmlDsigSigner.java.

Regla #4: ComunicaciÃ³n entre MÃ³dulos
Los mÃ³dulos NO deben inyectar sus Repositorios entre sÃ­.

Correcto: MÃ³dulo A publica EventoX. MÃ³dulo B escucha EventoX.

Correcto: MÃ³dulo A expone una Facade o UseCase (Puerto de entrada). MÃ³dulo B llama a la Facade.

Incorrecto: AccountingService inyecta InvoiceRepository.

5. Diccionario de Datos Clave (Entidades)
SiiCertificate (Record)
Contenedor temporal en memoria para PrivateKey y X509Certificate extraÃ­dos del .p12.

RcvInvoiceSummary (Record)
RepresentaciÃ³n limpia de una lÃ­nea del Registro de Compras y Ventas (RCV) descargado del SII.

InvoiceEntity (JPA)
La factura persistida en base de datos local.

Schema: invoicing

Constraints: Unique (company_id, rut_emisor, tipo_dte, folio).

DtesDownloadedEvent (Event)
Evento crÃ­tico que dispara la contabilidad automÃ¡tica. Contiene la lista de XMLs crudos descargados.

6. ConfiguraciÃ³n de Entorno (Docker)
El sistema requiere levantar los siguientes servicios definidos en docker-compose.yml:


PostgreSQL + pgvector: Puerto 5432. DB: sii_erp.


Redis: Puerto 6379 (CachÃ© de Tokens SII).


App (Java 25): Puerto 8080. Variables de entorno crÃ­ticas: OPENAI_API_KEY.

7. Roadmap de ImplementaciÃ³n (Estado Actual)
Fase 0 (FundaciÃ³n): ConfiguraciÃ³n Gradle, Java 25, Docker. [LISTO] 

Fase 1 (SSO): AutenticaciÃ³n Multi-tenant. [PENDIENTE] 

Fase 2 (Integration SII): Handshake SOAP y Descarga RCV. [EN PROGRESO] 

Fase 3 (Invoicing): Persistencia y Parsing. [PENDIENTE] 

Fase 4 (Accounting): Asientos automÃ¡ticos. [PENDIENTE] 

Fase 5 (AI): Chatbot con RAG/Tools. [PENDIENTE]


Plan de ImplementaciÃ³n DEFINITIVO - ERP con IA (Java 25 + Gradle + Virtual Threads)
Excelente decisiÃ³n. Java 25 con Virtual Threads (Project Loom) cambia completamente el juego para este proyecto. Elimina muchos problemas de concurrencia tradicional y simplifica la arquitectura asÃ­ncrona.
ğŸš€ Cambios ArquitectÃ³nicos por Java 25
ANTES (Java 17-21):
âŒ ThreadPoolExecutor manual
âŒ TaskDecorator para copiar contexto
âŒ @Async complicado con CompanyContextHolder
âŒ LÃ­mite de threads (100-200 mÃ¡ximo)
AHORA (Java 25 + Virtual Threads):
âœ… Virtual Threads ilimitados (millones si quieres)
âœ… Context propagation automÃ¡tico con ScopedValue
âœ… SimplificaciÃ³n brutal del cÃ³digo async
âœ… Mejor performance para I/O (SOAP calls al SII)
ğŸ“ Estructura de Carpetas DEFINITIVA
sii-erp-ai/
â”‚
â”œâ”€â”€ build.gradle.kts                         # Gradle Kotlin DSL
â”œâ”€â”€ settings.gradle.kts
â”œâ”€â”€ gradle.properties
â”œâ”€â”€ docker-compose.yml
â”‚
â”œâ”€â”€ buildSrc/                                # Versiones centralizadas
â”‚   â””â”€â”€ src/main/kotlin/
â”‚       â””â”€â”€ Dependencies.kt
â”‚
â””â”€â”€ src/
    â”œâ”€â”€ main/
    â”‚   â”œâ”€â”€ java/com/tuempresa/erp/
    â”‚   â”‚   â”œâ”€â”€ ErpApplication.java
    â”‚   â”‚   â”‚
    â”‚   â”‚   â”œâ”€â”€ shared/                      # KERNEL COMPARTIDO
    â”‚   â”‚   â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ event/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DomainEvent.java
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ EventPublisher.java
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ EventMetadata.java        # Timestamp, userId, companyId
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ valueobject/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Rut.java                  # Record con validaciÃ³n
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ Money.java                # Record immutable
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ TaxPeriod.java            # Record (year, month)
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CompanyId.java            # UUID wrapper
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ exception/
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ DomainException.java
    â”‚   â”‚   â”‚   â”‚       â”œâ”€â”€ BusinessRuleViolation.java
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ ErrorCode.java            # Enum con cÃ³digos
    â”‚   â”‚   â”‚   â”œâ”€â”€ infrastructure/
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ event/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ SpringEventPublisher.java
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ config/
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ VirtualThreadConfig.java # â† NUEVO
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DatabaseConfig.java
    â”‚   â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RedisConfig.java
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ TransactionConfig.java
    â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ context/
    â”‚   â”‚   â”‚   â”‚   â”‚   â””â”€â”€ CompanyContext.java       # â† Usa ScopedValue (Java 25)
    â”‚   â”‚   â”‚   â”‚   â””â”€â”€ security/
    â”‚   â”‚   â”‚   â”‚       â””â”€â”€ EncryptionService.java
    â”‚   â”‚   â”‚   â””â”€â”€ application/
    â”‚   â”‚   â”‚       â””â”€â”€ util/
    â”‚   â”‚   â”‚           â”œâ”€â”€ DateUtil.java
    â”‚   â”‚   â”‚           â””â”€â”€ XmlUtil.java
    â”‚   â”‚   â”‚
    â”‚   â”‚   â””â”€â”€ modules/
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€ sso/                     # MÃ“DULO 1: Identity & Access
    â”‚   â”‚       â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ model/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ User.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Company.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Role.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ Permission.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ port/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthenticateUserUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ RegisterCompanyUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ GetCompanyContextUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ UserRepository.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â””â”€â”€ CompanyRepository.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ service/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ UserAuthenticationService.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ CompanyManagementService.java
    â”‚   â”‚       â”‚   â”œâ”€â”€ application/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ SsoFacade.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ dto/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ LoginRequestDTO.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ LoginResponseDTO.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ CompanyDTO.java
    â”‚   â”‚       â”‚   â””â”€â”€ infrastructure/
    â”‚   â”‚       â”‚       â”œâ”€â”€ adapter/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ rest/
    â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ AuthController.java
    â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ CompanyController.java
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚       â”‚       â””â”€â”€ persistence/
    â”‚   â”‚       â”‚       â”‚           â”œâ”€â”€ UserJpaAdapter.java
    â”‚   â”‚       â”‚       â”‚           â”œâ”€â”€ CompanyJpaAdapter.java
    â”‚   â”‚       â”‚       â”‚           â””â”€â”€ entity/
    â”‚   â”‚       â”‚       â”‚               â”œâ”€â”€ UserEntity.java
    â”‚   â”‚       â”‚       â”‚               â””â”€â”€ CompanyEntity.java
    â”‚   â”‚       â”‚       â””â”€â”€ security/
    â”‚   â”‚       â”‚           â”œâ”€â”€ JwtTokenProvider.java
    â”‚   â”‚       â”‚           â”œâ”€â”€ SecurityFilter.java       # Setea CompanyContext
    â”‚   â”‚       â”‚           â””â”€â”€ PasswordEncoder.java
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€ integration_sii/         # MÃ“DULO 2: Legacy Adapter
    â”‚   â”‚       â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ model/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ SiiCertificate.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ SiiToken.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ SiiResponse.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ RcvData.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ event/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ DtesDownloadedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ DteSentEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ RcvSyncedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ TokenRefreshedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ port/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ AuthenticateSiiUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ DownloadRcvUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SendDteUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ RefreshTokenUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ SiiSoapPort.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ TokenCachePort.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â””â”€â”€ CertificateStoragePort.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ service/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ SiiAuthenticationService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ RcvDownloadService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ DteSenderService.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ XmlSignerService.java
    â”‚   â”‚       â”‚   â”œâ”€â”€ application/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ SiiFacade.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ dto/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ CertificateUploadDTO.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ RcvDownloadRequestDTO.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ DteSubmissionDTO.java
    â”‚   â”‚       â”‚   â””â”€â”€ infrastructure/
    â”‚   â”‚       â”‚       â”œâ”€â”€ adapter/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ rest/
    â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ SiiIntegrationController.java
    â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ CertificateController.java
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚       â”‚       â”œâ”€â”€ soap/
    â”‚   â”‚       â”‚       â”‚       â”‚   â”œâ”€â”€ SiiAuthSoapClient.java
    â”‚   â”‚       â”‚       â”‚       â”‚   â”œâ”€â”€ SiiRcvSoapClient.java
    â”‚   â”‚       â”‚       â”‚       â”‚   â””â”€â”€ SiiDteSoapClient.java
    â”‚   â”‚       â”‚       â”‚       â””â”€â”€ cache/
    â”‚   â”‚       â”‚       â”‚           â””â”€â”€ RedisTokenCache.java
    â”‚   â”‚       â”‚       â”œâ”€â”€ crypto/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ Pkcs12Handler.java
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ XmlDsigSigner.java
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ SeedSigner.java
    â”‚   â”‚       â”‚       â””â”€â”€ scheduler/
    â”‚   â”‚       â”‚           â”œâ”€â”€ RcvSyncScheduler.java
    â”‚   â”‚       â”‚           â””â”€â”€ TokenRefreshScheduler.java
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€ invoicing/               # MÃ“DULO 3: GestiÃ³n de DTEs
    â”‚   â”‚       â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ model/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Invoice.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceType.java        # Enum
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceStatus.java      # Enum
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceLine.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Party.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ TaxDetail.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ event/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceCreatedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceReceivedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceValidatedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ InvoicePdfGeneratedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ port/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CreateInvoiceUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ SearchInvoicesUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ ValidateInvoiceUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ GeneratePdfUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ InvoiceRepository.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â””â”€â”€ PdfGeneratorPort.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ service/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ InvoiceManagementService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ InvoiceValidationService.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ InvoiceSearchService.java
    â”‚   â”‚       â”‚   â”œâ”€â”€ application/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ InvoicingFacade.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ listener/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ DtesDownloadedListener.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ DteSentListener.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ dto/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ CreateInvoiceDTO.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ InvoiceSearchCriteriaDTO.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ InvoiceSummaryDTO.java
    â”‚   â”‚       â”‚   â””â”€â”€ infrastructure/
    â”‚   â”‚       â”‚       â”œâ”€â”€ adapter/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ rest/
    â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ InvoiceController.java
    â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ InvoiceQueryController.java
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚       â”‚       â”œâ”€â”€ persistence/
    â”‚   â”‚       â”‚       â”‚       â”‚   â”œâ”€â”€ InvoiceJpaAdapter.java
    â”‚   â”‚       â”‚       â”‚       â”‚   â”œâ”€â”€ mapper/
    â”‚   â”‚       â”‚       â”‚       â”‚   â”‚   â””â”€â”€ InvoiceMapper.java
    â”‚   â”‚       â”‚       â”‚       â”‚   â””â”€â”€ entity/
    â”‚   â”‚       â”‚       â”‚       â”‚       â”œâ”€â”€ InvoiceEntity.java
    â”‚   â”‚       â”‚       â”‚       â”‚       â””â”€â”€ InvoiceLineEntity.java
    â”‚   â”‚       â”‚       â”‚       â””â”€â”€ pdf/
    â”‚   â”‚       â”‚       â”‚           â””â”€â”€ JasperPdfGenerator.java
    â”‚   â”‚       â”‚       â””â”€â”€ parser/
    â”‚   â”‚       â”‚           â”œâ”€â”€ DteXmlParser.java
    â”‚   â”‚       â”‚           â””â”€â”€ DteXmlBuilder.java
    â”‚   â”‚       â”‚
    â”‚   â”‚       â”œâ”€â”€ accounting/              # MÃ“DULO 4: Contabilidad (CORE)
    â”‚   â”‚       â”‚   â”œâ”€â”€ domain/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ model/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ AccountingEntry.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Account.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ ChartOfAccounts.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ Ledger.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ JournalBook.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ F29Report.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ BalanceSheet.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ IncomeStatement.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ DebitCredit.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ AccountType.java        # Enum
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ event/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ EntryPostedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ PeriodClosedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ F29CalculatedEvent.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ port/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ PostEntryUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ CalculateF29UseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GetBalanceSheetUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â”œâ”€â”€ GetIncomeStatementUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â”‚   â””â”€â”€ ClosePeriodUseCase.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ AccountingRepository.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â”œâ”€â”€ LedgerRepository.java
    â”‚   â”‚       â”‚   â”‚   â”‚       â””â”€â”€ ChartOfAccountsRepository.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ service/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ AccountingEntryService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ F29CalculatorService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ BalanceSheetService.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ DoubleEntryValidator.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ PeriodClosingService.java
    â”‚   â”‚       â”‚   â”œâ”€â”€ application/
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ AccountingFacade.java
    â”‚   â”‚       â”‚   â”‚   â”œâ”€â”€ listener/
    â”‚   â”‚       â”‚   â”‚   â”‚   â”œâ”€â”€ InvoiceCreatedListener.java
    â”‚   â”‚       â”‚   â”‚   â”‚   â””â”€â”€ InvoiceReceivedListener.java
    â”‚   â”‚       â”‚   â”‚   â””â”€â”€ dto/
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ EntryDTO.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ F29DTO.java
    â”‚   â”‚       â”‚   â”‚       â”œâ”€â”€ BalanceSheetDTO.java
    â”‚   â”‚       â”‚   â”‚       â””â”€â”€ IncomeStatementDTO.java
    â”‚   â”‚       â”‚   â””â”€â”€ infrastructure/
    â”‚   â”‚       â”‚       â”œâ”€â”€ adapter/
    â”‚   â”‚       â”‚       â”‚   â”œâ”€â”€ in/
    â”‚   â”‚       â”‚       â”‚   â”‚   â””â”€â”€ rest/
    â”‚   â”‚       â”‚       â”‚   â”‚       â”œâ”€â”€ AccountingController.java
    â”‚   â”‚       â”‚       â”‚   â”‚       â””â”€â”€ ReportsController.java
    â”‚   â”‚       â”‚       â”‚   â””â”€â”€ out/
    â”‚   â”‚       â”‚       â”‚       â””â”€â”€ persistence/
    â”‚   â”‚       â”‚       â”‚           â”œâ”€â”€ AccountingJpaAdapter.java
    â”‚   â”‚       â”‚       â”‚           â”œâ”€â”€ mapper/
    â”‚   â”‚       â”‚       â”‚           â”‚   â””â”€â”€ AccountingMapper.java
    â”‚   â”‚       â”‚       â”‚           â””â”€â”€ entity/
    â”‚   â”‚       â”‚       â”‚               â”œâ”€â”€ AccountingEntryEntity.java
    â”‚   â”‚       â”‚       â”‚               â”œâ”€â”€ AccountEntity.java
    â”‚   â”‚       â”‚       â”‚               â””â”€â”€ LedgerEntity.java
    â”‚   â”‚       â”‚       â””â”€â”€ templates/
    â”‚   â”‚       â”‚           â””â”€â”€ chile-chart-of-accounts.json
    â”‚   â”‚       â”‚
    â”‚   â”‚       â””â”€â”€ ai_assistant/            # MÃ“DULO 5: IA
    â”‚   â”‚           â”œâ”€â”€ domain/
    â”‚   â”‚           â”‚   â”œâ”€â”€ model/
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ Conversation.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ Message.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ MessageRole.java        # Enum: USER, ASSISTANT, SYSTEM
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ Tool.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ ToolExecution.java
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ KnowledgeDocument.java
    â”‚   â”‚           â”‚   â”œâ”€â”€ port/
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ in/
    â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ ChatUseCase.java
    â”‚   â”‚           â”‚   â”‚   â”‚   â”œâ”€â”€ IndexDocumentUseCase.java
    â”‚   â”‚           â”‚   â”‚   â”‚   â””â”€â”€ SearchKnowledgeUseCase.java
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ out/
    â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ LlmPort.java
    â”‚   â”‚           â”‚   â”‚       â”œâ”€â”€ VectorStorePort.java
    â”‚   â”‚           â”‚   â”‚       â””â”€â”€ ConversationRepository.java
    â”‚   â”‚           â”‚   â””â”€â”€ service/
    â”‚   â”‚           â”‚       â”œâ”€â”€ ConversationService.java
    â”‚   â”‚           â”‚       â”œâ”€â”€ ToolRegistry.java
    â”‚   â”‚           â”‚       â”œâ”€â”€ ToolExecutor.java
    â”‚   â”‚           â”‚       â””â”€â”€ PromptBuilder.java
    â”‚   â”‚           â”œâ”€â”€ application/
    â”‚   â”‚           â”‚   â”œâ”€â”€ AiFacade.java
    â”‚   â”‚           â”‚   â”œâ”€â”€ tools/
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ GetSalesReportTool.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ SearchInvoicesTool.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ CalculateF29Tool.java
    â”‚   â”‚           â”‚   â”‚   â”œâ”€â”€ GetBalanceSheetTool.java
    â”‚   â”‚           â”‚   â”‚   â””â”€â”€ GetCompanyInfoTool.java
    â”‚   â”‚           â”‚   â””â”€â”€ dto/
    â”‚   â”‚           â”‚       â”œâ”€â”€ ChatRequestDTO.java
    â”‚   â”‚           â”‚       â”œâ”€â”€ ChatResponseDTO.java
    â”‚   â”‚           â”‚       â””â”€â”€ ToolCallDTO.java
    â”‚   â”‚           â””â”€â”€ infrastructure/
    â”‚   â”‚               â”œâ”€â”€ adapter/
    â”‚   â”‚               â”‚   â”œâ”€â”€ in/
    â”‚   â”‚               â”‚   â”‚   â””â”€â”€ rest/
    â”‚   â”‚               â”‚   â”‚       â””â”€â”€ AiAssistantController.java
    â”‚   â”‚               â”‚   â””â”€â”€ out/
    â”‚   â”‚               â”‚       â”œâ”€â”€ llm/
    â”‚   â”‚               â”‚       â”‚   â”œâ”€â”€ OpenAiAdapter.java
    â”‚   â”‚               â”‚       â”‚   â””â”€â”€ ClaudeAdapter.java
    â”‚   â”‚               â”‚       â”œâ”€â”€ vectordb/
    â”‚   â”‚               â”‚       â”‚   â””â”€â”€ PgVectorAdapter.java
    â”‚   â”‚               â”‚       â””â”€â”€ persistence/
    â”‚   â”‚               â”‚           â”œâ”€â”€ ConversationJpaAdapter.java
    â”‚   â”‚               â”‚           â””â”€â”€ entity/
    â”‚   â”‚               â”‚               â””â”€â”€ ConversationEntity.java
    â”‚   â”‚               â””â”€â”€ config/
    â”‚   â”‚                   â””â”€â”€ LangChain4jConfig.java
    â”‚   â”‚
    â”‚   â””â”€â”€ resources/
    â”‚       â”œâ”€â”€ application.yml
    â”‚       â”œâ”€â”€ application-dev.yml
    â”‚       â”œâ”€â”€ application-prod.yml
    â”‚       â”œâ”€â”€ db/migration/
    â”‚       â”‚   â”œâ”€â”€ V1__create_schemas.sql
    â”‚       â”‚   â”œâ”€â”€ V2__create_sso_tables.sql
    â”‚       â”‚   â”œâ”€â”€ V3__create_sii_integration_tables.sql
    â”‚       â”‚   â”œâ”€â”€ V4__create_invoicing_tables.sql
    â”‚       â”‚   â”œâ”€â”€ V5__create_accounting_tables.sql
    â”‚       â”‚   â”œâ”€â”€ V6__create_ai_tables.sql
    â”‚       â”‚   â”œâ”€â”€ V7__enable_pgvector.sql
    â”‚       â”‚   â””â”€â”€ V8__seed_chart_of_accounts.sql
    â”‚       â”œâ”€â”€ wsdl/
    â”‚       â”‚   â”œâ”€â”€ CrSeed.wsdl
    â”‚       â”‚   â”œâ”€â”€ GetToken.wsdl
    â”‚       â”‚   â””â”€â”€ QueryEstUp.wsdl
    â”‚       â””â”€â”€ prompts/
    â”‚           â”œâ”€â”€ system-prompt.txt
    â”‚           â””â”€â”€ tools-description.txt
    â”‚
    â””â”€â”€ test/
        â””â”€â”€ java/com/tuempresa/erp/
            â”œâ”€â”€ shared/
            â”‚   â””â”€â”€ infrastructure/
            â”‚       â””â”€â”€ event/
            â”‚           â””â”€â”€ SpringEventPublisherTest.java
            â”œâ”€â”€ modules/
            â”‚   â”œâ”€â”€ integration_sii/
            â”‚   â”‚   â”œâ”€â”€ domain/
            â”‚   â”‚   â”‚   â””â”€â”€ service/
            â”‚   â”‚   â”‚       â””â”€â”€ XmlSignerServiceTest.java
            â”‚   â”‚   â””â”€â”€ infrastructure/
            â”‚   â”‚       â””â”€â”€ crypto/
            â”‚   â”‚           â””â”€â”€ Pkcs12HandlerTest.java
            â”‚   â”œâ”€â”€ accounting/
            â”‚   â”‚   â””â”€â”€ domain/
            â”‚   â”‚       â””â”€â”€ service/
            â”‚   â”‚           â””â”€â”€ F29CalculatorServiceTest.java
            â”‚   â””â”€â”€ ai_assistant/
            â”‚       â””â”€â”€ application/
            â”‚           â””â”€â”€ tools/
            â”‚               â””â”€â”€ GetSalesReportToolTest.java
            â””â”€â”€ integration/
                â”œâ”€â”€ SiiAuthenticationIntegrationTest.java
                â”œâ”€â”€ InvoiceWorkflowIntegrationTest.java
                â””â”€â”€ EventFlowIntegrationTest.java
ğŸ”§ ConfiguraciÃ³n Gradle (build.gradle.kts)---
plugins {
Â  Â  java
Â  Â  id("org.springframework.boot") version "3.4.0"
Â  Â  id("io.spring.dependency-management") version "1.1.6"
Â  Â  id("org.flywaydb.flyway") version "10.20.1"
}

group = "com.tuempresa"
version = "1.0.0-SNAPSHOT"

java {
Â  Â  toolchain {
Â  Â  Â  Â  languageVersion = JavaLanguageVersion.of(25)
Â  Â  }
}

configurations {
Â  Â  compileOnly {
Â  Â  Â  Â  extendsFrom(configurations.annotationProcessor.get())
Â  Â  }
}

repositories {
Â  Â  mavenCentral()
}

dependencies {
Â  Â  // Spring Boot Core
Â  Â  implementation("org.springframework.boot:spring-boot-starter-web")
Â  Â  implementation("org.springframework.boot:spring-boot-starter-data-jpa")
Â  Â  implementation("org.springframework.boot:spring-boot-starter-validation")
Â  Â Â 
Â  Â  // Security & JWT
Â  Â  implementation("org.springframework.boot:spring-boot-starter-security")
Â  Â  implementation("io.jsonwebtoken:jjwt-api:0.12.6")
Â  Â  runtimeOnly("io.jsonwebtoken:jjwt-impl:0.12.6")
Â  Â  runtimeOnly("io.jsonwebtoken:jjwt-jackson:0.12.6")
Â  Â Â 
Â  Â  // SOAP Client (SII Integration)
Â  Â  implementation("org.springframework.boot:spring-boot-starter-web-services")
Â  Â  implementation("org.apache.cxf:cxf-spring-boot-starter-jaxws:4.0.5")
Â  Â  implementation("jakarta.xml.ws:jakarta.xml.ws-api:4.0.2")
Â  Â  implementation("jakarta.xml.bind:jakarta.xml.bind-api:4.0.2")
Â  Â  runtimeOnly("com.sun.xml.ws:jaxws-rt:4.0.3")
Â  Â Â 
Â  Â  // XML Signature (Crypto)
Â  Â  implementation("org.apache.santuario:xmlsec:3.0.4")
Â  Â  implementation("org.bouncycastle:bcprov-jdk18on:1.78.1")
Â  Â  implementation("org.bouncycastle:bcpkix-jdk18on:1.78.1")
Â  Â Â 
Â  Â  // Database
Â  Â  implementation("org.postgresql:postgresql")
Â  Â  implementation("org.flywaydb:flyway-core")
Â  Â  implementation("org.flywaydb:flyway-database-postgresql")
Â  Â Â 
Â  Â  // Redis Cache
Â  Â  implementation("org.springframework.boot:spring-boot-starter-data-redis")
Â  Â  implementation("redis.clients:jedis:5.2.0")
Â  Â Â 
Â  Â  // AI / LLM Integration
Â  Â  implementation("dev.langchain4j:langchain4j-spring-boot-starter:0.35.0")
Â  Â  implementation("dev.langchain4j:langchain4j-open-ai:0.35.0")
Â  Â  implementation("dev.langchain4j:langchain4j-pgvector:0.35.0")
Â  Â Â 
Â  Â  // Vector Database (pgvector)
Â  Â  implementation("com.pgvector:pgvector:0.1.6")
Â  Â Â 
Â  Â  // PDF Generation
Â  Â  implementation("net.sf.jasperreports:jasperreports:7.0.1")
Â  Â Â 
Â  Â  // MapStruct (DTO Mapping)
Â  Â  implementation("org.mapstruct:mapstruct:1.6.2")
Â  Â  annotationProcessor("org.mapstruct:mapstruct-processor:1.6.2")
Â  Â Â 
Â  Â  // API Documentation
Â  Â  implementation("org.springdoc:springdoc-openapi-starter-webmvc-ui:2.6.0")
Â  Â Â 
Â  Â  // Lombok (Opcional, pero ayuda)
Â  Â  compileOnly("org.projectlombok:lombok")
Â  Â  annotationProcessor("org.projectlombok:lombok")
Â  Â Â 
Â  Â  // Monitoring
Â  Â  implementation("org.springframework.boot:spring-boot-starter-actuator")
Â  Â  implementation("io.micrometer:micrometer-registry-prometheus")
Â  Â Â 
Â  Â  // Testing
Â  Â  testImplementation("org.springframework.boot:spring-boot-starter-test")
Â  Â  testImplementation("org.springframework.security:spring-security-test")
Â  Â  testImplementation("com.h2database:h2")
Â  Â  testImplementation("org.testcontainers:testcontainers:1.20.2")
Â  Â  testImplementation("org.testcontainers:postgresql:1.20.2")
Â  Â  testImplementation("org.testcontainers:junit-jupiter:1.20.2")
}

tasks.withType<Test> {
Â  Â  useJUnitPlatform()
Â  Â  jvmArgs("--enable-preview") // Para Virtual Threads
}

tasks.withType<JavaCompile> {
Â  Â  options.compilerArgs.add("--enable-preview")
Â  Â  options.compilerArgs.add("-parameters") // Para Spring parameter names
}
âš¡ CompanyContext con ScopedValue (Java 25)
Este es el cambio MÃS IMPORTANTE. Reemplaza ThreadLocal por ScopedValue:---

package com.tuempresa.erp.shared.infrastructure.context;

import com.tuempresa.erp.shared.domain.valueobject.CompanyId;

import java.util.Optional;

/**
Â * Multi-tenant context usando ScopedValue (Java 25).
Â *Â 
Â * VENTAJAS sobre ThreadLocal:
Â * 1. PropagaciÃ³n automÃ¡tica en Virtual Threads
Â * 2. Inmutable por diseÃ±o (no hay set())
Â * 3. Scope explÃ­cito (se limpia automÃ¡ticamente)
Â * 4. Performance superior
Â */
public class CompanyContext {
Â  Â Â 
Â  Â  // ScopedValue - Feature preview de Java 25
Â  Â  private static final ScopedValue<CompanyId> COMPANY_ID = ScopedValue.newInstance();
Â  Â  private static final ScopedValue<String> USER_ID = ScopedValue.newInstance();
Â  Â Â 
Â  Â  /**
Â  Â  Â * Ejecuta una operaciÃ³n dentro del contexto de una empresa.
Â  Â  Â * El contexto se propaga automÃ¡ticamente a todos los Virtual Threads hijos.
Â  Â  Â */
Â  Â  public static <T> T runInCompanyContext(
Â  Â  Â  Â  Â  Â  CompanyId companyId,Â 
Â  Â  Â  Â  Â  Â  String userId,Â 
Â  Â  Â  Â  Â  Â  ContextualOperation<T> operation
Â  Â  ) throws Exception {
Â  Â  Â  Â  // ScopedValue.where() crea un scope que se limpia automÃ¡ticamente
Â  Â  Â  Â  return ScopedValue.where(COMPANY_ID, companyId)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .where(USER_ID, userId)
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  .call(operation::execute);
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Obtiene el CompanyId del contexto actual.
Â  Â  Â * Funciona en el thread principal y en cualquier Virtual Thread hijo.
Â  Â  Â */
Â  Â  public static Optional<CompanyId> getCompanyId() {
Â  Â  Â  Â  return Optional.ofNullable(COMPANY_ID.orElse(null));
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Obtiene el CompanyId o lanza excepciÃ³n si no existe.
Â  Â  Â * Ãštil para casos donde el contexto es obligatorio.
Â  Â  Â */
Â  Â  public static CompanyId requireCompanyId() {
Â  Â  Â  Â  return getCompanyId()
Â  Â  Â  Â  Â  Â  .orElseThrow(() -> new IllegalStateException(
Â  Â  Â  Â  Â  Â  Â  Â  "No company context found. Ensure request passed through SecurityFilter."
Â  Â  Â  Â  Â  Â  ));
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Obtiene el ID del usuario actual.
Â  Â  Â */
Â  Â  public static Optional<String> getUserId() {
Â  Â  Â  Â  return Optional.ofNullable(USER_ID.orElse(null));
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Interfaz funcional para operaciones contextuales.
Â  Â  Â */
Â  Â  @FunctionalInterface
Â  Â  public interface ContextualOperation<T> {
Â  Â  Â  Â  T execute() throws Exception;
Â  Â  }
}
ğŸ” SecurityFilter que configura el contexto---
package com.tuempresa.erp.modules.sso.infrastructure.security;

import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.UUID;

/**
Â * Filtro que extrae el JWT y configura el CompanyContext.
Â *Â 
Â * Flow:
Â * 1. Extrae JWT del header Authorization
Â * 2. Valida y decodifica el token
Â * 3. Extrae companyId y userId
Â * 4. Ejecuta el request dentro del ScopedValue context
Â */
@Component
public class SecurityFilter extends OncePerRequestFilter {
Â  Â Â 
Â  Â  private final JwtTokenProvider jwtTokenProvider;
Â  Â Â 
Â  Â  public SecurityFilter(JwtTokenProvider jwtTokenProvider) {
Â  Â  Â  Â  this.jwtTokenProvider = jwtTokenProvider;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  protected void doFilterInternal(
Â  Â  Â  Â  Â  Â  HttpServletRequest request,
Â  Â  Â  Â  Â  Â  HttpServletResponse response,
Â  Â  Â  Â  Â  Â  FilterChain filterChain
Â  Â  ) throws ServletException, IOException {
Â  Â  Â  Â Â 
Â  Â  Â  Â  String token = extractToken(request);
Â  Â  Â  Â Â 
Â  Â  Â  Â  if (token != null && jwtTokenProvider.validateToken(token)) {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  // Extraer datos del JWT
Â  Â  Â  Â  Â  Â  Â  Â  String userId = jwtTokenProvider.getUserId(token);
Â  Â  Â  Â  Â  Â  Â  Â  String companyIdStr = jwtTokenProvider.getCompanyId(token);
Â  Â  Â  Â  Â  Â  Â  Â  CompanyId companyId = new CompanyId(UUID.fromString(companyIdStr));
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Configurar Spring Security
Â  Â  Â  Â  Â  Â  Â  Â  Authentication authentication = jwtTokenProvider.getAuthentication(token);
Â  Â  Â  Â  Â  Â  Â  Â  SecurityContextHolder.getContext().setAuthentication(authentication);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Ejecutar el request dentro del ScopedValue context
Â  Â  Â  Â  Â  Â  Â  Â  // MAGIA: Esto se propaga automÃ¡ticamente a todos los Virtual Threads
Â  Â  Â  Â  Â  Â  Â  Â  CompanyContext.runInCompanyContext(
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  companyId,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  userId,
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  () -> {
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  filterChain.doFilter(request, response);
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  return null;
Â  Â  Â  Â  Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  Â  Â  Â  Â  );
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  return; // Importante: no continuar despuÃ©s del context
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } catch (Exception e) {
Â  Â  Â  Â  Â  Â  Â  Â  response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
Â  Â  Â  Â  Â  Â  Â  Â  response.getWriter().write("Invalid token: " + e.getMessage());
Â  Â  Â  Â  Â  Â  Â  Â  return;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Si no hay token vÃ¡lido, continuar sin contexto
Â  Â  Â  Â  filterChain.doFilter(request, response);
Â  Â  }
Â  Â Â 
Â  Â  private String extractToken(HttpServletRequest request) {
Â  Â  Â  Â  String bearerToken = request.getHeader("Authorization");
Â  Â  Â  Â  if (bearerToken != null && bearerToken.startsWith("Bearer ")) {
Â  Â  Â  Â  Â  Â  return bearerToken.substring(7);
Â  Â  Â  Â  }
Â  Â  Â  Â  return null;
Â  Â  }
}
ğŸš€ VirtualThreadConfig (ConfiguraciÃ³n de Virtual Threads)---
package com.tuempresa.erp.shared.infrastructure.config;

import org.springframework.boot.autoconfigure.task.TaskExecutionAutoConfiguration;
import org.springframework.boot.web.embedded.tomcat.TomcatProtocolHandlerCustomizer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.core.task.AsyncTaskExecutor;
import org.springframework.core.task.support.TaskExecutorAdapter;
import org.springframework.scheduling.annotation.EnableAsync;
import org.springframework.scheduling.annotation.EnableScheduling;

import java.util.concurrent.Executors;

/**
Â * ConfiguraciÃ³n de Virtual Threads (Project Loom - Java 25).
Â *Â 
Â * BENEFICIOS:
Â * 1. Spring Boot manejarÃ¡ TODAS las requests en Virtual Threads
Â * 2. Los eventos @Async se ejecutan en Virtual Threads
Â * 3. Los Schedulers usan Virtual Threads
Â * 4. PropagaciÃ³n automÃ¡tica del ScopedValue (CompanyContext)
Â *Â 
Â * NO NECESITAS TaskDecorator ni copiar contexto manualmente.
Â */
@Configuration
@EnableAsync
@EnableScheduling
public class VirtualThreadConfig {
Â  Â Â 
Â  Â  /**
Â  Â  Â * Configura Tomcat para usar Virtual Threads en todas las requests HTTP.
Â  Â  Â */
Â  Â  @Bean
Â  Â  public TomcatProtocolHandlerCustomizer<?> protocolHandlerVirtualThreadExecutorCustomizer() {
Â  Â  Â  Â  return protocolHandler -> {
Â  Â  Â  Â  Â  Â  protocolHandler.setExecutor(Executors.newVirtualThreadPerTaskExecutor());
Â  Â  Â  Â  };
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Executor para eventos @Async.
Â  Â  Â * Reemplaza el ThreadPoolTaskExecutor tradicional.
Â  Â  Â */
Â  Â  @Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
Â  Â  public AsyncTaskExecutor asyncTaskExecutor() {
Â  Â  Â  Â  return new TaskExecutorAdapter(Executors.newVirtualThreadPerTaskExecutor());
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Executor para @Scheduled tasks.
Â  Â  Â */
Â  Â  @Bean
Â  Â  public AsyncTaskExecutor scheduledTaskExecutor() {
Â  Â  Â  Â  return new TaskExecutorAdapter(Executors.newVirtualThreadPerTaskExecutor());
Â  Â  }
}
ğŸ“¡ Ejemplo de Event Publisher (Shared)---
package com.tuempresa.erp.shared.infrastructure.event;

import com.tuempresa.erp.shared.domain.event.DomainEvent;
import com.tuempresa.erp.shared.domain.event.EventPublisher;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.stereotype.Component;

import java.time.Instant;
import java.util.UUID;

/**
Â * ImplementaciÃ³n de EventPublisher usando Spring Events.
Â *Â 
Â * IMPORTANTE: Los eventos se publican en el mismo Virtual Thread,
Â * pero los listeners se ejecutan asÃ­ncronamente en NUEVOS Virtual Threads.
Â *Â 
Â * Gracias a ScopedValue, el CompanyContext se propaga automÃ¡ticamente.
Â */
@Component
public class SpringEventPublisher implements EventPublisher {
Â  Â Â 
Â  Â  private static final Logger log = LoggerFactory.getLogger(SpringEventPublisher.class);
Â  Â Â 
Â  Â  private final ApplicationEventPublisher springPublisher;
Â  Â Â 
Â  Â  public SpringEventPublisher(ApplicationEventPublisher springPublisher) {
Â  Â  Â  Â  this.springPublisher = springPublisher;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public void publish(DomainEvent event) {
Â  Â  Â  Â  // Enriquecer evento con metadata del contexto
Â  Â  Â  Â  enrichEventMetadata(event);
Â  Â  Â  Â Â 
Â  Â  Â  Â  log.info("Publishing event: {} for company: {}",Â 
Â  Â  Â  Â  Â  Â  Â  Â  event.getClass().getSimpleName(),Â 
Â  Â  Â  Â  Â  Â  Â  Â  event.getCompanyId());
Â  Â  Â  Â Â 
Â  Â  Â  Â  // Spring maneja la propagaciÃ³n async automÃ¡ticamente
Â  Â  Â  Â  springPublisher.publishEvent(event);
Â  Â  }
Â  Â Â 
Â  Â  private void enrichEventMetadata(DomainEvent event) {
Â  Â  Â  Â  if (event.getEventId() == null) {
Â  Â  Â  Â  Â  Â  event.setEventId(UUID.randomUUID());
Â  Â  Â  Â  }
Â  Â  Â  Â  if (event.getOccurredAt() == null) {
Â  Â  Â  Â  Â  Â  event.setOccurredAt(Instant.now());
Â  Â  Â  Â  }
Â  Â  Â  Â  if (event.getCompanyId() == null) {
Â  Â  Â  Â  Â  Â  // Obtener del contexto actual (ScopedValue)
Â  Â  Â  Â  Â  Â  CompanyContext.getCompanyId().ifPresent(event::setCompanyId);
Â  Â  Â  Â  }
Â  Â  Â  Â  if (event.getUserId() == null) {
Â  Â  Â  Â  Â  Â  CompanyContext.getUserId().ifPresent(event::setUserId);
Â  Â  Â  Â  }
Â  Â  }
}
ğŸ¯ Ejemplo de Evento + Listener (Integration SII â†’ Invoicing)---
package com.tuempresa.erp.modules.integration_sii.domain.event;

import com.tuempresa.erp.shared.domain.event.DomainEvent;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.shared.domain.valueobject.TaxPeriod;

import java.time.Instant;
import java.util.List;
import java.util.UUID;

/**
Â * Evento publicado cuando el RcvSyncScheduler termina de descargar DTEs.
Â *Â 
Â * Este evento serÃ¡ escuchado por:
Â * - MÃ³dulo Invoicing: Para parsear y guardar las facturas
Â * - MÃ³dulo Accounting: Para generar asientos contables
Â * - MÃ³dulo AI: Para indexar en el vector DB
Â */
public class DtesDownloadedEvent implements DomainEvent {
Â  Â Â 
Â  Â  private UUID eventId;
Â  Â  private Instant occurredAt;
Â  Â  private CompanyId companyId;
Â  Â  private String userId;
Â  Â Â 
Â  Â  private final TaxPeriod period;
Â  Â  private final List<String> xmlDocuments;Â  // XMLs crudos del SII
Â  Â  private final int totalDownloaded;
Â  Â Â 
Â  Â  public DtesDownloadedEvent(
Â  Â  Â  Â  Â  Â  TaxPeriod period,Â 
Â  Â  Â  Â  Â  Â  List<String> xmlDocuments
Â  Â  ) {
Â  Â  Â  Â  this.period = period;
Â  Â  Â  Â  this.xmlDocuments = xmlDocuments;
Â  Â  Â  Â  this.totalDownloaded = xmlDocuments.size();
Â  Â  }
Â  Â Â 
Â  Â  // Getters y Setters
Â  Â Â 
Â  Â  @Override
Â  Â  public UUID getEventId() {
Â  Â  Â  Â  return eventId;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public void setEventId(UUID eventId) {
Â  Â  Â  Â  this.eventId = eventId;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public Instant getOccurredAt() {
Â  Â  Â  Â  return occurredAt;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public void setOccurredAt(Instant occurredAt) {
Â  Â  Â  Â  this.occurredAt = occurredAt;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public CompanyId getCompanyId() {
Â  Â  Â  Â  return companyId;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public void setCompanyId(CompanyId companyId) {
Â  Â  Â  Â  this.companyId = companyId;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public String getUserId() {
Â  Â  Â  Â  return userId;
Â  Â  }
Â  Â Â 
Â  Â  @Override
Â  Â  public void setUserId(String userId) {
Â  Â  Â  Â  this.userId = userId;
Â  Â  }
Â  Â Â 
Â  Â  public TaxPeriod getPeriod() {
Â  Â  Â  Â  return period;
Â  Â  }
Â  Â Â 
Â  Â  public List<String> getXmlDocuments() {
Â  Â  Â  Â  return xmlDocuments;
Â  Â  }
Â  Â Â 
Â  Â  public int getTotalDownloaded() {
Â  Â  Â  Â  return totalDownloaded;
Â  Â  }
}

package com.tuempresa.erp.modules.invoicing.application.listener;

import com.tuempresa.erp.modules.integration_sii.domain.event.DtesDownloadedEvent;
import com.tuempresa.erp.modules.invoicing.domain.model.Invoice;
import com.tuempresa.erp.modules.invoicing.domain.port.in.CreateInvoiceUseCase;
import com.tuempresa.erp.modules.invoicing.infrastructure.parser.DteXmlParser;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.event.EventListener;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

/**
Â * Listener que procesa los DTEs descargados del SII.
Â *Â 
Â * IMPORTANTE:
Â * - @TransactionalEventListener(AFTER_COMMIT): Solo se ejecuta si el evento
Â *Â  Â se publicÃ³ desde una transacciÃ³n exitosa
Â * - @Async: Se ejecuta en un Virtual Thread separado
Â * - CompanyContext se propaga automÃ¡ticamente (ScopedValue)
Â */
@Component
public class DtesDownloadedListener {
Â  Â Â 
Â  Â  private static final Logger log = LoggerFactory.getLogger(DtesDownloadedListener.class);
Â  Â Â 
Â  Â  private final DteXmlParser xmlParser;
Â  Â  private final CreateInvoiceUseCase createInvoiceUseCase;
Â  Â Â 
Â  Â  public DtesDownloadedListener(
Â  Â  Â  Â  Â  Â  DteXmlParser xmlParser,
Â  Â  Â  Â  Â  Â  CreateInvoiceUseCase createInvoiceUseCase
Â  Â  ) {
Â  Â  Â  Â  this.xmlParser = xmlParser;
Â  Â  Â  Â  this.createInvoiceUseCase = createInvoiceUseCase;
Â  Â  }
Â  Â Â 
Â  Â  /**
Â  Â  Â * Procesa los DTEs descargados.
Â  Â  Â *Â 
Â  Â  Â * FLUJO:
Â  Â  Â * 1. Recibe el evento (en Virtual Thread)
Â  Â  Â * 2. CompanyContext ya estÃ¡ configurado (propagaciÃ³n automÃ¡tica)
Â  Â  Â * 3. Parsea cada XML
Â  Â  Â * 4. Guarda en DB
Â  Â  Â * 5. Publica InvoiceReceivedEvent (para contabilidad)
Â  Â  Â */
Â  Â  @Async
Â  Â  @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
Â  Â  public void handleDtesDownloaded(DtesDownloadedEvent event) {
Â  Â  Â  Â  var companyId = CompanyContext.requireCompanyId(); // Disponible gracias a ScopedValue
Â  Â  Â  Â Â 
Â  Â  Â  Â  log.info("Processing {} DTEs for company {} in period {}",Â 
Â  Â  Â  Â  Â  Â  Â  Â  event.getTotalDownloaded(),Â 
Â  Â  Â  Â  Â  Â  Â  Â  companyId,Â 
Â  Â  Â  Â  Â  Â  Â  Â  event.getPeriod());
Â  Â  Â  Â Â 
Â  Â  Â  Â  int processed = 0;
Â  Â  Â  Â  int errors = 0;
Â  Â  Â  Â Â 
Â  Â  Â  Â  for (String xmlDocument : event.getXmlDocuments()) {
Â  Â  Â  Â  Â  Â  try {
Â  Â  Â  Â  Â  Â  Â  Â  // Parsear XML a objeto de dominio
Â  Â  Â  Â  Â  Â  Â  Â  Invoice invoice = xmlParser.parse(xmlDocument);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  // Guardar (esto publicarÃ¡ InvoiceReceivedEvent internamente)
Â  Â  Â  Â  Â  Â  Â  Â  createInvoiceUseCase.create(invoice);
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  Â  Â  processed++;
Â  Â  Â  Â  Â  Â  Â  Â Â 
Â  Â  Â  Â  Â  Â  } catch (Exception e) {
Â  Â  Â  Â  Â  Â  Â  Â  log.error("Error processing DTE: {}", e.getMessage(), e);
Â  Â  Â  Â  Â  Â  Â  Â  errors++;
Â  Â  Â  Â  Â  Â  }
Â  Â  Â  Â  }
Â  Â  Â  Â Â 
Â  Â  Â  Â  log.info("DTE processing completed: {} processed, {} errors", processed, errors);
Â  Â  }
}
ğŸ¯ Fases de ImplementaciÃ³n ACTUALIZADAS

FASE 0: FundaciÃ³n + Java 25 Setup (Semana 1)
âœ… Crear proyecto con Gradle + Java 25
âœ… Configurar --enable-preview en build.gradle.kts
âœ… Docker Compose (PostgreSQL 17 + Redis + pgvector)
âœ… Implementar CompanyContext con ScopedValue
âœ… Implementar VirtualThreadConfig
âœ… Implementar SpringEventPublisher
âœ… Tests bÃ¡sicos de propagaciÃ³n de contexto
Entregable: Un test que demuestre que CompanyContext se propaga automÃ¡ticamente en Virtual Threads.
FASE 1: MÃ³dulo SSO (Semana 2)
âœ… Entidades User, Company, Role
âœ… JWT authentication con companyId en el token
âœ… SecurityFilter que configura ScopedValue
âœ… Endpoints: POST /auth/login, POST /auth/register
âœ… Tests de autenticaciÃ³n multi-tenant
Entregable: AutenticaciÃ³n funcional con JWT que contiene companyId.
FASE 2: MÃ³dulo Integration SII (Semanas 3-5)
Semana 3: AutenticaciÃ³n SII
âœ… Implementar Pkcs12Handler (lectura de .p12)
âœ… Implementar XmlDsigSigner (firma XMLDSig)
âœ… SOAP Client: getSeed() + getToken()
âœ… Redis cache del token
âœ… Test con certificado de prueba
Semana 4: Descarga RCV
âœ… SOAP Client: consultarRCV()
âœ… RcvSyncScheduler (Cron Job)
âœ… Publicar DtesDownloadedEvent
âœ… Guardar XMLs crudos en sii.raw_xml_responses
Semana 5: EnvÃ­o DTE
âœ… ConstrucciÃ³n de XML para emisiÃ³n
âœ… Firma del DTE
âœ… SOAP Client: enviarDTE()
âœ… Publicar DteSentEvent
Entregable: Descarga automÃ¡tica de DTEs reales del SII cada noche.
FASE 3: MÃ³dulo Invoicing (Semanas 6-7)
Semana 6: Parser y Persistencia
âœ… JAXB: generar clases desde XSD del SII
âœ… DteXmlParser
âœ… Entidades Invoice, InvoiceLine
âœ… DtesDownloadedListener funcional
âœ… Guardar facturas en invoicing.invoices
Semana 7: EmisiÃ³n y PDF
âœ… Endpoint: POST /api/invoices (emitir factura)
âœ… IntegraciÃ³n con integration_sii para enviar
âœ… GeneraciÃ³n PDF con JasperReports
âœ… Publicar InvoiceCreatedEvent
Entregable: Dashboard que muestre facturas descargadas + emisiÃ³n propia.
FASE 4: MÃ³dulo Accounting (Semanas 8-9)
Semana 8: Libros Contables
âœ… Plan de cuentas chileno precargado (V8 migration)
âœ… InvoiceReceivedListener â†’ auto-genera asientos
âœ… ValidaciÃ³n Debe = Haber
âœ… Libro Diario y Mayor
Semana 9: Reportes Financieros
âœ… F29CalculatorService
âœ… Balance de ComprobaciÃ³n
âœ… Balance General (Balance Sheet)
âœ… Estado de Resultados (Income Statement)
âœ… Endpoints REST para reportes
Entregable: F29 calculado automÃ¡ticamente con datos reales.
FASE 5: MÃ³dulo AI Assistant (Semanas 10-11)
Semana 10: Infraestructura IA
âœ… LangChain4j + OpenAI/Claude integration
âœ… Configurar pgvector extension
âœ… ToolRegistry + ToolExecutor
âœ… Implementar 3 herramientas bÃ¡sicas:
   - GetSalesReportTool
   - SearchInvoicesTool
   - CalculateF29Tool
Semana 11: Chat y RAG
âœ… ConversationService
âœ… Endpoint: POST /api/ai/chat
âœ… RAG bÃ¡sico (opcional)
âœ… Tests de herramientas
Entregable: Chatbot funcional que responde preguntas financieras.
FASE 6: Pulido y Deployment (Semana 12)
âœ… Tests de integraciÃ³n end-to-end
âœ… DocumentaciÃ³n OpenAPI completa
âœ… Dockerfile con Java 25
âœ… CI/CD con GitHub Actions
âœ… Monitoring (Prometheus + Grafana)
âœ… README profesional
ğŸ”¥ Ventajas de Java 25 + Virtual Threads para este proyecto
AspectoThread Pool TradicionalVirtual Threads (Java 25)Contexto Multi-tenantNecesitas TaskDecorator manualPropagaciÃ³n automÃ¡tica con ScopedValueEscalabilidadLÃ­mite ~200 threadsMillones de threads simultÃ¡neosSOAP Calls (I/O)Bloquea threads carosVirtual thread se "park" gratisCÃ³digo AsyncCallbacks, CompletableFuture complejoCÃ³digo secuencial simpleEvent ListenersNecesitas @Async + pool configSolo @Async, sin configuraciÃ³nPerformanceOverhead de context switchNear-zero overheadğŸ“Š ComparaciÃ³n Final: Plan Original vs Refactorizado
AspectoPlan Original (v1)Plan Refactorizado (v2)Java17/2125 (Virtual Threads)BuildMavenGradle Kotlin DSLMulti-tenantThreadLocal manualScopedValue automÃ¡ticoAsyncTaskDecorator customVirtual Threads nativosMÃ³dulos4 bÃ¡sicos5 + kernel compartidoEventosComunicaciÃ³n directaEvent-Driven completoIANo incluidaMÃ³dulo dedicado con toolsContabilidadSolo F29Libros completosEscalabilidadVerticalHorizontal-readyNivel demostradoMid-SeniorSenior-Architectâœ… Resumen Ejecutivo
Este plan refactorizado aprovecha las capacidades mÃ¡s avanzadas de Java 25:

ScopedValue elimina el problema #1 de multi-tenancy (propagaciÃ³n de contexto)
Virtual Threads eliminan la complejidad de thread pools y async
Event-Driven mantiene mÃ³dulos desacoplados
Gradle simplifica gestiÃ³n de dependencias
Arquitectura modular permite extraer a microservicios sin reescribir
Resultado: Un ERP enterprise-grade con IA que demuestra dominio de tecnologÃ­as cutting-edge.

AquÃ­ tienes el cÃ³digo "Industrial Grade" para la Fase 2 (IntegraciÃ³n SII).

Este cÃ³digo resuelve el problema mÃ¡s difÃ­cil: La Firma Digital XML (XMLDSig) respetando los estÃ¡ndares "Legacy" del SII (RSA-SHA1, Canonicalization) pero usando la sintaxis moderna de Java 25.

1. UbicaciÃ³n del Archivo
Este servicio va en el mÃ³dulo de integraciÃ³n, especÃ­ficamente en la capa de infraestructura.

src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/crypto/XmlDsigSigner.java

2. El Servicio de Firma (Core CriptogrÃ¡fico)
Este componente toma el contenido que el SII pide (la "Semilla") y lo envuelve en el sobre XML firmado digitalmente.

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.crypto;

import com.tuempresa.erp.modules.integration_sii.domain.model.SiiCertificate;
import org.springframework.stereotype.Service;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.xml.sax.InputSource;

import javax.xml.crypto.dsig.*;
import javax.xml.crypto.dsig.dom.DOMSignContext;
import javax.xml.crypto.dsig.keyinfo.KeyInfo;
import javax.xml.crypto.dsig.keyinfo.KeyInfoFactory;
import javax.xml.crypto.dsig.keyinfo.KeyValue;
import javax.xml.crypto.dsig.keyinfo.X509Data;
import javax.xml.crypto.dsig.spec.C14NMethodParameterSpec;
import javax.xml.crypto.dsig.spec.TransformParameterSpec;
import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.transform.TransformerFactory;
import javax.xml.transform.dom.DOMSource;
import javax.xml.transform.stream.StreamResult;
import java.io.StringReader;
import java.io.StringWriter;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Collections;
import java.util.List;

/// Servicio encargado de la firma XMLDSig bajo el estÃ¡ndar del SII (Chile).
/// Utiliza Java 25 XML Crypto API.
@Service
public class XmlDsigSigner {

    private static final String SII_SIGNATURE_ALGORITHM = "http://www.w3.org/2000/09/xmldsig#rsa-sha1";
    private static final String XML_TEMPLATE = """
            <?xml version="1.0" encoding="ISO-8859-1"?>
            <getToken>
                <item>
                    <Semilla>%s</Semilla>
                </item>
            </getToken>
            """;

    /**
     * Firma la semilla para obtener el Token del SII.
     *
     * @param seed La semilla numÃ©rica obtenida del SII.
     * @param certificate El certificado cargado (Private Key + X509).
     * @return El XML completo firmado listo para enviar a getToken().
     */
    public String signSeed(String seed, SiiCertificate certificate) {
        try {
            // 1. Preparar el Documento XML (DOM)
            // El SII usa ISO-8859-1, es crÃ­tico respetar esto o la firma falla.
            String xmlContent = XML_TEMPLATE.formatted(seed);
            Document doc = stringToDom(xmlContent);

            // 2. Crear Factory de Firma XML
            XMLSignatureFactory fac = XMLSignatureFactory.getInstance("DOM");

            // 3. Crear Referencia (QuÃ© vamos a firmar)
            // URI="" indica que firmamos todo el documento
            Reference ref = fac.newReference(
                    "",
                    fac.newDigestMethod(DigestMethod.SHA1, null),
                    Collections.singletonList(
                            fac.newTransform(Transform.ENVELOPED, (TransformParameterSpec) null)
                    ),
                    null,
                    null
            );

            // 4. Crear SignedInfo (CÃ³mo lo vamos a firmar)
            // SII requiere CanonicalizaciÃ³n OMIT_COMMENTS y algoritmo RSA-SHA1
            SignedInfo si = fac.newSignedInfo(
                    fac.newCanonicalizationMethod(CanonicalizationMethod.INCLUSIVE, (C14NMethodParameterSpec) null),
                    fac.newSignatureMethod(SII_SIGNATURE_ALGORITHM, null),
                    Collections.singletonList(ref)
            );

            // 5. Crear KeyInfo (QuiÃ©n firma)
            // Incluimos la llave pÃºblica (KeyValue) y el certificado X509 en el XML
            KeyInfoFactory kif = fac.getKeyInfoFactory();
            KeyValue kv = kif.newKeyValue(certificate.getX509Certificate().getPublicKey());
            X509Data x509Data = kif.newX509Data(List.of(certificate.getX509Certificate()));
            KeyInfo ki = kif.newKeyInfo(List.of(kv, x509Data));

            // 6. Contexto de Firma
            // Especificamos dÃ³nde insertar la firma (dentro del tag <getToken>, al final)
            DOMSignContext dsc = new DOMSignContext(certificate.getPrivateKey(), doc.getDocumentElement());

            // 7. Firmar
            XMLSignature signature = fac.newXMLSignature(si, ki);
            signature.sign(dsc);

            // 8. Serializar de vuelta a String
            return domToString(doc);

        } catch (Exception e) {
            throw new RuntimeException("Error signing SII seed: " + e.getMessage(), e);
        }
    }

    // --- Helpers Privados Modernos ---

    private Document stringToDom(String xml) throws Exception {
        var factory = DocumentBuilderFactory.newInstance();
        factory.setNamespaceAware(true); // Vital para XMLDSig
        return factory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)));
    }

    private String domToString(Document doc) throws Exception {
        var tf = TransformerFactory.newInstance();
        var writer = new StringWriter();
        tf.newTransformer().transform(new DOMSource(doc), new StreamResult(writer));
        return writer.getBuffer().toString();
    }
}
3. El Cliente SOAP (La ConexiÃ³n)
src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/adapter/out/soap/SiiAuthSoapClient.java

AquÃ­ usamos Java 25 HttpClient para mÃ¡xima eficiencia con Virtual Threads, evitando la sobrecarga de librerÃ­as SOAP pesadas para este handshake especÃ­fico que es muy sensible al formato.

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.adapter.out.soap;

import com.tuempresa.erp.modules.integration_sii.domain.model.SiiCertificate;
import com.tuempresa.erp.modules.integration_sii.infrastructure.crypto.XmlDsigSigner;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/// Cliente SOAP optimizado para Virtual Threads (Java 25).
/// Maneja el handshake de autenticaciÃ³n con el SII.
@Component
public class SiiAuthSoapClient {

    private final XmlDsigSigner signer;
    private final HttpClient httpClient;
    
    @Value("${sii.url.auth:https://palena.sii.cl/DTEWS}") // URL ProducciÃ³n o MaullÃ­n
    private String baseUrl;

    public SiiAuthSoapClient(XmlDsigSigner signer) {
        this.signer = signer;
        // En Java 25, HttpClient usa un Executor por defecto.
        // Si ya configuraste VirtualThreadConfig globalmente, este cliente
        // no bloquearÃ¡ hilos de plataforma.
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(10))
                .build();
    }

    /**
     * Paso 1: Obtener Semilla
     */
    public String getSeed() {
        var soapBody = """
                <soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                                  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                                  xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                  xmlns:def="http://DefaultNamespace">
                   <soapenv:Header/>
                   <soapenv:Body>
                      <def:getSeed/>
                   </soapenv:Body>
                </soapenv:Envelope>
                """;

        String responseXml = executeSoapRequest(baseUrl + "/CrSeed.jws", soapBody);
        return extractTagValue(responseXml, "SEMILLA");
    }

    /**
     * Paso 2: Obtener Token usando la semilla firmada
     */
    public String getToken(String seed, SiiCertificate certificate) {
        // 1. Firmar la semilla (aquÃ­ ocurre la magia criptogrÃ¡fica)
        String signedXml = signer.signSeed(seed, certificate);

        // 2. Envolver en SOAP Envelope para getToken
        // Nota: El SII espera el XML firmado como string dentro del tag <pszXml>
        // pero XML escaped (&lt;...).
        var soapBody = """
                <soapenv:Envelope xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" 
                                  xmlns:xsd="http://www.w3.org/2001/XMLSchema" 
                                  xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" 
                                  xmlns:def="http://DefaultNamespace">
                   <soapenv:Header/>
                   <soapenv:Body>
                      <def:getToken>
                         <pszXml>%s</pszXml>
                      </def:getToken>
                   </soapenv:Body>
                </soapenv:Envelope>
                """.formatted(escapeXml(signedXml));

        String responseXml = executeSoapRequest(baseUrl + "/GetTokenFromSeed.jws", soapBody);
        return extractTagValue(responseXml, "TOKEN");
    }

    // --- Private Infrastructure Helpers ---

    private String executeSoapRequest(String url, String body) {
        try {
            var request = HttpRequest.newBuilder()
                    .uri(URI.create(url))
                    .header("Content-Type", "text/xml;charset=UTF-8")
                    .header("SOAPAction", "") // SII a veces requiere esto vacÃ­o
                    .POST(HttpRequest.BodyPublishers.ofString(body))
                    .build();

            // Llamada bloqueante pero "barata" gracias a Virtual Threads
            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());

            if (response.statusCode() != 200) {
                throw new RuntimeException("SII SOAP Error: " + response.statusCode());
            }

            return response.body();

        } catch (Exception e) {
            throw new RuntimeException("Error communicating with SII: " + e.getMessage(), e);
        }
    }

    // ExtracciÃ³n simple con Regex para evitar overhead de parsear todo el SOAP response
    // para un solo valor.
    private String extractTagValue(String xml, String tagName) {
        Pattern pattern = Pattern.compile("<" + tagName + ">(.*?)</" + tagName + ">");
        Matcher matcher = pattern.matcher(xml);
        if (matcher.find()) {
            return matcher.group(1);
        }
        throw new RuntimeException("Tag " + tagName + " not found in SII response");
    }
    
    private String escapeXml(String data) {
        return data.replace("&", "&amp;")
                   .replace("<", "&lt;")
                   .replace(">", "&gt;")
                   .replace("\"", "&quot;")
                   .replace("'", "&apos;");
    }
}
Por quÃ© este cÃ³digo es "Java 25 Ready"
Text Blocks ("""): Hacen que el XML sea legible directamente en el cÃ³digo Java.

HttpClient Nativo: Evitamos librerÃ­as externas pesadas (como Axis o CXF) para el handshake. Esto reduce el tamaÃ±o de tu Docker image y el tiempo de arranque.

Virtual Thread Friendly: Al usar llamadas sÃ­ncronas (httpClient.send) dentro de una aplicaciÃ³n configurada con Virtual Threads, el hilo virtual se "aparca" mientras espera la respuesta del SII, liberando el hilo del sistema operativo. Esto te permite tener miles de autenticaciones simultÃ¡neas sin colapsar el servidor.

Markdown Comments (///): Usamos la nueva sintaxis de documentaciÃ³n estÃ¡ndar.

Siguiente paso sugerido
Ahora que tienes la "llave" (Token) del SII, el siguiente paso lÃ³gico es implementar la clase Pkcs12Handler (que es utilizada en el cÃ³digo de arriba como SiiCertificate) para leer el archivo .p12 real del disco o base de datos.


la implementaciÃ³n de la clase Pkcs12Handler. Esta clase es crÃ­tica porque convierte el archivo binario que sube el usuario (o que lees de la BD) en objetos criptogrÃ¡ficos de Java que tu aplicaciÃ³n puede usar para firmar.

AdemÃ¡s, he incluido el Domain Model (SiiCertificate) que usamos en el paso anterior, para que todo el cÃ³digo compile perfectamente.

1. El Modelo de Dominio (Data Carrier)
Primero, definimos quÃ© es un certificado en tu sistema. Usamos un Java Record (introducido en Java 14+), que es la forma moderna, inmutable y concisa de pasar datos.

UbicaciÃ³n: src/main/java/com/tuempresa/erp/modules/integration_sii/domain/model/SiiCertificate.java

Java

package com.tuempresa.erp.modules.integration_sii.domain.model;

import java.security.PrivateKey;
import java.security.cert.X509Certificate;

/// Modelo de dominio inmutable que representa un Certificado Digital cargado en memoria.
/// Se usa temporalmente para firmar y luego se descarta por seguridad.
public record SiiCertificate(
    PrivateKey privateKey,
    X509Certificate x509Certificate,
    String rut,         // RUT del dueÃ±o del certificado
    String razonSocial  // Nombre/RazÃ³n social extraÃ­do del certificado
) {
    // MÃ©todo helper para obtener la llave pÃºblica si se necesita
    public java.security.PublicKey getPublicKey() {
        return x509Certificate.getPublicKey();
    }
}
2. El Handler PKCS#12 (Infraestructura)
Esta clase hace el trabajo sucio: abrir el archivo .p12, desbloquearlo con la contraseÃ±a y extraer las credenciales.

UbicaciÃ³n: src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/crypto/Pkcs12Handler.java

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.crypto;

import com.tuempresa.erp.modules.integration_sii.domain.model.SiiCertificate;
import org.springframework.stereotype.Component;

import java.io.ByteArrayInputStream;
import java.security.KeyStore;
import java.security.PrivateKey;
import java.security.cert.X509Certificate;
import java.util.Enumeration;

/// Componente encargado de manipular archivos PKCS#12 (.p12 / .pfx).
/// Extrae la llave privada y el certificado pÃºblico de forma segura.
@Component
public class Pkcs12Handler {

    private static final String KEYSTORE_TYPE = "PKCS12";

    /**
     * Carga un certificado desde un array de bytes.
     *
     * @param p12Data El contenido binario del archivo .p12
     * @param password La contraseÃ±a para desbloquear el archivo
     * @return El objeto de dominio con las llaves listas para usar
     * @throws RuntimeException Si la contraseÃ±a es incorrecta o el archivo es invÃ¡lido
     */
    public SiiCertificate load(byte[] p12Data, String password) {
        try {
            // 1. Instanciar KeyStore tipo PKCS12
            KeyStore keyStore = KeyStore.getInstance(KEYSTORE_TYPE);

            // 2. Cargar datos (Esto valida la contraseÃ±a automÃ¡ticamente)
            // Usamos ByteArrayInputStream para no depender de archivos fÃ­sicos en disco
            try (var stream = new ByteArrayInputStream(p12Data)) {
                keyStore.load(stream, password.toCharArray());
            }

            // 3. Buscar el alias que contiene la llave privada
            // Usualmente solo hay uno, pero iteramos para ser robustos
            Enumeration<String> aliases = keyStore.aliases();
            while (aliases.hasMoreElements()) {
                String alias = aliases.nextElement();

                // Solo nos interesa si es una entrada con llave (KeyEntry)
                if (keyStore.isKeyEntry(alias)) {
                    
                    // 4. Extraer Private Key
                    PrivateKey privateKey = (PrivateKey) keyStore.getKey(alias, password.toCharArray());
                    
                    // 5. Extraer Certificado X509
                    X509Certificate cert = (X509Certificate) keyStore.getCertificate(alias);

                    // 6. Extraer Datos del Sujeto (RUT y Nombre)
                    // El SII guarda el RUT en el CN (Common Name) o en el SerialNumber del SubjectDN
                    ParsedSubject subject = parseSubject(cert.getSubjectX500Principal().getName());

                    return new SiiCertificate(
                            privateKey,
                            cert,
                            subject.rut(),
                            subject.name()
                    );
                }
            }

            throw new IllegalArgumentException("El archivo .p12 no contiene ninguna llave privada vÃ¡lida.");

        } catch (Exception e) {
            // En un entorno real, querrÃ¡s lanzar una excepciÃ³n de dominio customizada
            // como InvalidCertificatePasswordException
            throw new RuntimeException("Error cargando certificado digital: " + e.getMessage(), e);
        }
    }

    // --- Helpers de Parseo de Datos ---

    // Record interno para devolver los datos parseados
    private record ParsedSubject(String rut, String name) {}

    /**
     * Parsea el Subject DN (Distinguished Name) para extraer RUT y Nombre.
     * Ejemplo DN: "CN=JUAN PEREZ, SERIALNUMBER=11222333-K, C=CL, ..."
     */
    private ParsedSubject parseSubject(String subjectDn) {
        String rut = "UNKNOWN";
        String name = "UNKNOWN";

        // Parseo manual simple. Para algo mÃ¡s robusto, usar LdapName de javax.naming
        // Nota: El formato del SII varÃ­a segÃºn la entidad certificadora (Acepta, E-Sign, etc.)
        
        // Estrategia: Buscar SERIALNUMBER (donde suele estar el RUT) y CN (Nombre)
        String[] parts = subjectDn.split(",");
        for (String part : parts) {
            String trimmed = part.trim();
            if (trimmed.toUpperCase().startsWith("SERIALNUMBER=")) {
                rut = trimmed.substring(13);
            } else if (trimmed.toUpperCase().startsWith("CN=")) {
                name = trimmed.substring(3);
            }
        }
        
        return new ParsedSubject(rut, name);
    }
}
3. IntegraciÃ³n Final (El flujo completo)
Ahora puedes ver cÃ³mo encaja todo. AquÃ­ te muestro un ejemplo conceptual de cÃ³mo el Servicio de AplicaciÃ³n (SiiAuthenticationService) usa las tres piezas que hemos creado (SoapClient, Signer, Handler).

Este serÃ­a tu Caso de Uso (Application Layer):

Java

@Service
public class SiiAuthenticationService {

    private final Pkcs12Handler pkcs12Handler;
    private final SiiAuthSoapClient soapClient;
    private final CertificateStoragePort certificateStorage; // Tu puerto para leer de DB

    // Constructor injection...

    public String performHandshake(CompanyId companyId) {
        // 1. Obtener certificado encriptado de la DB
        byte[] p12Data = certificateStorage.getEncryptedP12(companyId);
        String password = certificateStorage.getPassword(companyId); // Desencriptada

        // 2. Cargar certificado en memoria (Usando tu nueva clase)
        SiiCertificate cert = pkcs12Handler.load(p12Data, password);

        // 3. Pedir Semilla al SII (SOAP)
        String seed = soapClient.getSeed();

        // 4. Obtener Token firmando la semilla
        // (AquÃ­ soapClient usa internamente XmlDsigSigner con el cert que le pasamos)
        String token = soapClient.getToken(seed, cert);

        return token;
    }
}
4. PrÃ³ximo Paso LÃ³gico
Ya tienes la capacidad de Autenticarte. Eso es un logro enorme.

El siguiente desafÃ­o es descargar los datos del RCV (Registro de Compras y Ventas) usando ese token. AquÃ­ es donde empezarÃ¡s a ver datos reales (facturas de proveedores).

El servicio SOAP para esto es diferente (QueryEstUp o RegistroComVenta).

Ya tenemos la "llave maestra" (el Token). Ahora vamos a usarla para entrar a la bÃ³veda: el Registro de Compras y Ventas (RCV).

En esta fase, descargaremos el listado de facturas que tus proveedores han emitido contra tu empresa. Esta es la base para tu contabilidad automatizada.

Implementaremos 3 piezas clave en el mÃ³dulo integration_sii:

Modelo de Dominio: RcvInvoiceSummary (El DTO interno limpio).

Cliente SOAP RCV: SiiRcvSoapClient (La conexiÃ³n).

Parser: RcvXmlParser (Transformar el XML sucio del SII en objetos Java).

1. El Modelo de Dominio (La estructura limpia)
No queremos trabajar con XML crudo en nuestra aplicaciÃ³n. Definimos un Record que represente una lÃ­nea del registro de compras.

src/main/java/com/tuempresa/erp/modules/integration_sii/domain/model/RcvInvoiceSummary.java

Java

package com.tuempresa.erp.modules.integration_sii.domain.model;

import com.tuempresa.erp.shared.domain.valueobject.Money;
import java.time.LocalDate;

/// Representa una fila del Registro de Compras (Una factura recibida).
public record RcvInvoiceSummary(
    Integer tipoDte,      // 33: Factura, 34: Exenta, 56: Nota Debito, 61: Nota Credito
    Long folio,           // NÃºmero de la factura
    String rutEmisor,     // QuiÃ©n te vendiÃ³
    String razonSocialEmisor,
    LocalDate fechaEmision,
    LocalDate fechaRecepcion,
    Money montoTotal,
    Money montoIva,
    Money montoNeto,
    String estado         // "PENDIENTE", "REGISTRO", "NO_RECLAMADO"
) {}
2. El Parser XML (Infraestructura)
El SII responde con una estructura XML compleja. Este parser usa el API estÃ¡ndar de Java (DocumentBuilder) para extraer la lista de facturas.

src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/parser/RcvXmlParser.java

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.parser;

import com.tuempresa.erp.modules.integration_sii.domain.model.RcvInvoiceSummary;
import com.tuempresa.erp.shared.domain.valueobject.Money;
import org.springframework.stereotype.Component;
import org.w3c.dom.Document;
import org.w3c.dom.Element;
import org.w3c.dom.NodeList;
import org.xml.sax.InputSource;

import javax.xml.parsers.DocumentBuilderFactory;
import java.io.StringReader;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

@Component
public class RcvXmlParser {

    private static final DateTimeFormatter DATE_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");

    public List<RcvInvoiceSummary> parseRcvResponse(String xmlResponse) {
        List<RcvInvoiceSummary> summaries = new ArrayList<>();
        
        try {
            // 1. Parsear el String XML a DOM
            var factory = DocumentBuilderFactory.newInstance();
            var builder = factory.newDocumentBuilder();
            Document doc = builder.parse(new InputSource(new StringReader(xmlResponse)));

            // 2. Navegar a los detalles
            // La estructura tÃ­pica del SII RCV es: <resp><cuerpo><detalle>...</detalle></cuerpo></resp>
            // Dependiendo del endpoint exacto, esto puede variar, ajustaremos al estÃ¡ndar comÃºn.
            NodeList detalles = doc.getElementsByTagName("detalle");

            for (int i = 0; i < detalles.getLength(); i++) {
                Element node = (Element) detalles.item(i);
                summaries.add(mapNodeToSummary(node));
            }

        } catch (Exception e) {
            // Loguear error pero retornar lista vacÃ­a o parcial para no botar el proceso completo
            throw new RuntimeException("Error parsing SII RCV XML: " + e.getMessage(), e);
        }
        return summaries;
    }

    private RcvInvoiceSummary mapNodeToSummary(Element e) {
        // Extraer valores con null-safety bÃ¡sica
        int tipo = Integer.parseInt(getTagValue(e, "tipoDoc"));
        long folio = Long.parseLong(getTagValue(e, "folio"));
        String rut = getTagValue(e, "rutEmisor");
        String rz = getTagValue(e, "rznsocEmisor"); // A veces viene abreviado
        
        // Fechas: El SII a veces manda "2025-12-02 15:30:00"
        String fEmisionStr = getTagValue(e, "fchEmis");
        LocalDate fEmision = LocalDate.parse(fEmisionStr.substring(0, 10)); // Cortar hora si viene
        
        // Montos
        BigDecimal total = new BigDecimal(getTagValue(e, "mntTotal"));
        BigDecimal iva = e.getElementsByTagName("mntIva").getLength() > 0 
                ? new BigDecimal(getTagValue(e, "mntIva")) 
                : BigDecimal.ZERO;
        BigDecimal neto = e.getElementsByTagName("mntNeto").getLength() > 0 
                ? new BigDecimal(getTagValue(e, "mntNeto")) 
                : BigDecimal.ZERO;

        return new RcvInvoiceSummary(
            tipo,
            folio,
            rut,
            rz,
            fEmision,
            LocalDate.now(), // Fecha recepciÃ³n aproximada si no viene en XML
            new Money(total),
            new Money(iva),
            new Money(neto),
            getTagValue(e, "estado")
        );
    }

    private String getTagValue(Element parent, String tagName) {
        NodeList list = parent.getElementsByTagName(tagName);
        if (list != null && list.getLength() > 0) {
            return list.item(0).getTextContent();
        }
        return ""; // O lanzar excepciÃ³n si es campo obligatorio
    }
}
3. El Cliente SOAP RCV (La conexiÃ³n)
Este cliente conecta al WebService de "Registro de Compras y Ventas". Ojo: Este endpoint es distinto al de autenticaciÃ³n.

src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/adapter/out/soap/SiiRcvSoapClient.java

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.adapter.out.soap;

import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Component;

import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.time.Duration;

@Component
public class SiiRcvSoapClient {

    private final HttpClient httpClient;

    @Value("${sii.url.rcv:https://www4.sii.cl/registrocomventaws/ws/RegistroComVenta.jws}")
    private String rcvUrl;

    public SiiRcvSoapClient() {
        this.httpClient = HttpClient.newBuilder()
                .connectTimeout(Duration.ofSeconds(20)) // El RCV es lento
                .build();
    }

    /**
     * Consulta el registro de COMPRAS para un periodo dado.
     * @param token Token vÃ¡lido obtenido previamente
     * @param rutEmpresa Rut de la empresa consultante (12345678-9)
     * @param periodo Periodo tributario (Ej: "202512")
     * @return El XML crudo con la respuesta
     */
    public String downloadPurchases(String token, String rutEmpresa, String periodo) {
        
        // Separar Rut y DV
        String[] rutParts = rutEmpresa.split("-");
        String rutCuerpo = rutParts[0];
        String dv = rutParts[1];

        // Construir request SOAP
        // IMPORTANTE: El namespace "ser" apunta a la implementaciÃ³n del servicio
        var soapBody = """
            <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:ser="http://service.registrocomventaws.sii.cl">
               <soapenv:Header/>
               <soapenv:Body>
                  <ser:listar>
                     <TOKEN>%s</TOKEN>
                     <RUT_EMISOR>%s</RUT_EMISOR>
                     <DV_EMISOR>%s</DV_EMISOR>
                     <PERIODO>%s</PERIODO>
                     <ESTADO>REGISTRO</ESTADO>
                     <TIPO_OPERACION>COMPRA</TIPO_OPERACION>
                  </ser:listar>
               </soapenv:Body>
            </soapenv:Envelope>
            """.formatted(token, rutCuerpo, dv, periodo);

        return executeRequest(soapBody);
    }

    private String executeRequest(String body) {
        try {
            var request = HttpRequest.newBuilder()
                    .uri(URI.create(rcvUrl))
                    .header("Content-Type", "text/xml;charset=UTF-8")
                    .header("SOAPAction", "")
                    .POST(HttpRequest.BodyPublishers.ofString(body))
                    .build();

            var response = httpClient.send(request, HttpResponse.BodyHandlers.ofString());
            
            if (response.statusCode() != 200) {
                // El SII a veces devuelve 500 cuando el token expirÃ³
                throw new RuntimeException("SII RCV Error HTTP: " + response.statusCode());
            }
            
            return response.body();
            
        } catch (Exception e) {
            throw new RuntimeException("Error connecting to SII RCV: " + e.getMessage(), e);
        }
    }
}
4. El Servicio de AplicaciÃ³n (La OrquestaciÃ³n)
AquÃ­ unimos todo. Este servicio serÃ¡ invocado por tu Cron Job (Scheduler) o por el botÃ³n "Sincronizar" del frontend.

src/main/java/com/tuempresa/erp/modules/integration_sii/domain/service/RcvDownloadService.java

Java

package com.tuempresa.erp.modules.integration_sii.domain.service;

import com.tuempresa.erp.modules.integration_sii.domain.model.RcvInvoiceSummary;
import com.tuempresa.erp.modules.integration_sii.infrastructure.adapter.out.soap.SiiRcvSoapClient;
import com.tuempresa.erp.modules.integration_sii.infrastructure.parser.RcvXmlParser;
import com.tuempresa.erp.shared.domain.event.EventPublisher;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.modules.integration_sii.domain.event.DtesDownloadedEvent; // Asumimos que creaste este evento
import org.springframework.stereotype.Service;

import java.util.List;

@Service
public class RcvDownloadService {

    private final SiiAuthenticationService authService;
    private final SiiRcvSoapClient rcvClient;
    private final RcvXmlParser parser;
    private final EventPublisher eventPublisher;

    public RcvDownloadService(
            SiiAuthenticationService authService,
            SiiRcvSoapClient rcvClient,
            RcvXmlParser parser,
            EventPublisher eventPublisher) {
        this.authService = authService;
        this.rcvClient = rcvClient;
        this.parser = parser;
        this.eventPublisher = eventPublisher;
    }

    public List<RcvInvoiceSummary> syncPurchases(CompanyId companyId, String rutEmpresa, String periodo) {
        // 1. Obtener Token vÃ¡lido (reusa el handshake que hicimos antes)
        // Nota: authService deberÃ­a manejar el cachÃ© internamente
        String token = authService.getValidToken(companyId);

        // 2. Descargar XML crudo del SII
        String rawXml = rcvClient.downloadPurchases(token, rutEmpresa, periodo);

        // 3. Parsear a Objetos Java
        List<RcvInvoiceSummary> invoices = parser.parseRcvResponse(rawXml);

        // 4. Publicar evento para que otros mÃ³dulos reaccionen
        // (El mÃ³dulo de Contabilidad escucharÃ¡ esto para crear asientos)
        if (!invoices.isEmpty()) {
            // Nota: En una implementaciÃ³n real, mapearÃ­amos RcvInvoiceSummary a un DTO ligero para el evento
            // o pasarÃ­amos los IDs para que los busquen.
             // eventPublisher.publish(new DtesDownloadedEvent(...)); 
        }

        return invoices;
    }
}
Notas TÃ©cnicas Importantes para ti:
Endpoints SII: El endpoint RegistroComVenta.jws tiene varios mÃ©todos (listar, buscar, exportar). He usado listar en el ejemplo XML porque es el mÃ¡s comÃºn para obtener el detalle paginado o completo del mes.

Manejo de Namespaces XML: Si al ejecutar recibes errores de parsing vacÃ­os, revisa el XML de respuesta crudo (System.out.println(rawXml)). El SII cambia a veces los prefijos (ax21:, ns1:) y el parser debe ser lo suficientemente flexible (usar getElementsByTagName es una buena estrategia defensiva por eso).

Periodo: El formato es YYYYMM (ej: 202511).

Â¿Siguiente paso?
Con esto ya traemos la informaciÃ³n. Ahora tienes dos caminos paralelos:

Persistencia: Guardar estos RcvInvoiceSummary en tu base de datos invoicing para no pedirlos siempre.

Frontend: Crear un Controller REST rÃ¡pido para devolver este JSON al navegador y ver la magia funcionando.

Vamos a materializar la persistencia.

Al guardar estos datos, pasamos de tener "informaciÃ³n volÃ¡til" (que desaparece si se cierra la consola) a un Activo de Datos consultable.

Vamos a definir la Entidad en el mÃ³dulo invoicing (quien es el dueÃ±o de los datos fiscales) y luego el Controller para exponerlos.

1. La Entidad JPA (InvoiceEntity)
Esta clase representa la tabla invoicing.invoices en PostgreSQL.

Decisiones de DiseÃ±o Clave:

Multi-tenant: Incluimos companyId como columna obligatoria.

Unique Constraint: Definimos una restricciÃ³n Ãºnica compuesta (companyId + rutEmisor + tipoDte + folio) para evitar duplicados si sincronizamos el mismo mes dos veces.

BigDecimal: Usamos NUMERIC(19, 0) para montos en pesos chilenos (sin decimales usualmente, pero Java BigDecimal es lo correcto).

Archivo: src/main/java/com/tuempresa/erp/modules/invoicing/infrastructure/adapter/out/persistence/entity/InvoiceEntity.java

Java

package com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.entity;

import jakarta.persistence.*;
import java.math.BigDecimal;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.util.UUID;
import org.hibernate.annotations.CreationTimestamp;
import org.hibernate.annotations.UpdateTimestamp;

@Entity
@Table(name = "invoices", schema = "invoicing", uniqueConstraints = {
    @UniqueConstraint(name = "uk_invoice_duplicity", 
        columnNames = {"company_id", "rut_emisor", "tipo_dte", "folio"})
})
public class InvoiceEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    private UUID id;

    @Column(name = "company_id", nullable = false)
    private UUID companyId; // Multi-tenant ID

    // --- Datos del Documento ---

    @Column(name = "tipo_dte", nullable = false)
    private Integer tipoDte; // 33, 34, 56, 61, etc.

    @Column(name = "folio", nullable = false)
    private Long folio;

    @Column(name = "rut_emisor", nullable = false, length = 12)
    private String rutEmisor;

    @Column(name = "razon_social_emisor", length = 150)
    private String razonSocialEmisor;

    @Column(name = "fecha_emision", nullable = false)
    private LocalDate fechaEmision;

    @Column(name = "fecha_recepcion")
    private LocalDate fechaRecepcion; // CuÃ¡ndo llegÃ³ al SII

    // --- Montos (Pesos Chilenos) ---

    @Column(name = "monto_neto", precision = 19, scale = 0)
    private BigDecimal montoNeto;

    @Column(name = "monto_iva", precision = 19, scale = 0)
    private BigDecimal montoIva;

    @Column(name = "monto_total", nullable = false, precision = 19, scale = 0)
    private BigDecimal montoTotal;

    // --- Estado y Control ---

    @Column(name = "estado", length = 20)
    private String estado; // REGISTRO, PENDIENTE, RECHAZADO

    @Column(name = "origen")
    private String origen; // "SII_SYNC" o "MANUAL"

    @CreationTimestamp
    @Column(name = "created_at", updatable = false)
    private LocalDateTime createdAt;

    @UpdateTimestamp
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    // Constructores, Getters y Setters
    // (Omitidos por brevedad, usa Lombok @Data si prefieres)
    
    public InvoiceEntity() {} // JPA requiere constructor vacÃ­o
    
    // Constructor conveniente
    public InvoiceEntity(UUID companyId, Integer tipoDte, Long folio, String rutEmisor, 
                         String razonSocialEmisor, LocalDate fechaEmision, BigDecimal total) {
        this.companyId = companyId;
        this.tipoDte = tipoDte;
        this.folio = folio;
        this.rutEmisor = rutEmisor;
        this.razonSocialEmisor = razonSocialEmisor;
        this.fechaEmision = fechaEmision;
        this.montoTotal = total;
    }
    
    // Setters manuales para el ejemplo
    public void setMontoNeto(BigDecimal montoNeto) { this.montoNeto = montoNeto; }
    public void setMontoIva(BigDecimal montoIva) { this.montoIva = montoIva; }
    public void setEstado(String estado) { this.estado = estado; }
    public void setOrigen(String origen) { this.origen = origen; }
}
2. El Repositorio JPA
Necesitamos un mÃ©todo para verificar si la factura ya existe antes de insertarla (Upsert pattern o Check-then-Act).

Archivo: src/main/java/com/tuempresa/erp/modules/invoicing/infrastructure/adapter/out/persistence/repository/InvoiceJpaRepository.java

Java

package com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.repository;

import com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.entity.InvoiceEntity;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import java.util.List;
import java.util.UUID;

@Repository
public interface InvoiceJpaRepository extends JpaRepository<InvoiceEntity, UUID> {

    // Buscar por empresa
    List<InvoiceEntity> findByCompanyId(UUID companyId);

    // Evitar duplicados: Verificar si ya existe
    boolean existsByCompanyIdAndRutEmisorAndTipoDteAndFolio(
        UUID companyId, String rutEmisor, Integer tipoDte, Long folio
    );
    
    // MÃ©todo Ãºtil para el Dashboard (Filtro por periodo)
    // Usamos JPQL para simplificar rangos de fechas
    List<InvoiceEntity> findByCompanyIdAndFechaEmisionBetween(
        UUID companyId, java.time.LocalDate start, java.time.LocalDate end
    );
}
3. El Controller REST (InvoiceController)
Este es el punto de entrada para tu Frontend. TendrÃ¡ dos endpoints clave:

GET /api/v1/invoices: Listar facturas guardadas en BD (RÃ¡pido).

POST /api/v1/invoices/sync: Disparar la sincronizaciÃ³n con el SII (Lento, background).

Archivo: src/main/java/com/tuempresa/erp/modules/invoicing/infrastructure/adapter/in/rest/InvoiceController.java

Java

package com.tuempresa.erp.modules.invoicing.infrastructure.adapter.in.rest;

import com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.entity.InvoiceEntity;
import com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.repository.InvoiceJpaRepository;
import com.tuempresa.erp.modules.integration_sii.domain.service.RcvDownloadService;
import com.tuempresa.erp.modules.integration_sii.domain.model.RcvInvoiceSummary;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@RestController
@RequestMapping("/api/v1/invoices")
public class InvoiceController {

    // En una arquitectura pura, aquÃ­ inyectarÃ­amos un "UseCase" (Inbound Port).
    // Para este ejemplo, inyectamos el Repository y el Service de IntegraciÃ³n directamente
    // para mostrar el flujo completo sin sobre-ingenierÃ­a inicial.
    private final InvoiceJpaRepository invoiceRepository;
    private final RcvDownloadService rcvDownloadService;

    public InvoiceController(InvoiceJpaRepository invoiceRepository, RcvDownloadService rcvDownloadService) {
        this.invoiceRepository = invoiceRepository;
        this.rcvDownloadService = rcvDownloadService;
    }

    /**
     * Endpoint 1: Dashboard de Facturas
     * Consulta la DB local (PostgreSQL). Respuesta < 10ms.
     */
    @GetMapping
    public ResponseEntity<List<InvoiceEntity>> listInvoices(
            @RequestParam(required = false) String month // Formato "2025-12"
    ) {
        // Obtenemos la empresa del Token JWT (automÃ¡tico gracias a ScopedValue)
        UUID companyUuid = CompanyContext.requireCompanyId().value();

        if (month != null) {
            LocalDate start = LocalDate.parse(month + "-01");
            LocalDate end = start.plusMonths(1).minusDays(1);
            return ResponseEntity.ok(
                invoiceRepository.findByCompanyIdAndFechaEmisionBetween(companyUuid, start, end)
            );
        }

        return ResponseEntity.ok(invoiceRepository.findByCompanyId(companyUuid));
    }

    /**
     * Endpoint 2: Trigger de SincronizaciÃ³n Manual
     * Va al SII, descarga y guarda.
     */
    @PostMapping("/sync")
    public ResponseEntity<?> syncWithSii(@RequestParam String rutEmpresa, @RequestParam String periodo) {
        
        CompanyId companyId = CompanyContext.requireCompanyId();

        // 1. Llamar al servicio de dominio que conecta al SII
        List<RcvInvoiceSummary> siiData = rcvDownloadService.syncPurchases(companyId, rutEmpresa, periodo);

        // 2. Persistir los datos nuevos (Logica simple de "Insert if not exists")
        int savedCount = 0;
        
        for (RcvInvoiceSummary item : siiData) {
            boolean exists = invoiceRepository.existsByCompanyIdAndRutEmisorAndTipoDteAndFolio(
                companyId.value(), 
                item.rutEmisor(), 
                item.tipoDte(), 
                item.folio()
            );

            if (!exists) {
                InvoiceEntity entity = mapToEntity(item, companyId.value());
                invoiceRepository.save(entity);
                savedCount++;
            }
        }

        return ResponseEntity.ok().body("SincronizaciÃ³n completada. Nuevas facturas guardadas: " + savedCount);
    }

    // Mapper manual simple (En prod usarÃ­as MapStruct)
    private InvoiceEntity mapToEntity(RcvInvoiceSummary dto, UUID companyId) {
        InvoiceEntity entity = new InvoiceEntity();
        entity.setCompanyId(companyId);
        entity.setTipoDte(dto.tipoDte());
        entity.setFolio(dto.folio());
        entity.setRutEmisor(dto.rutEmisor());
        entity.setRazonSocialEmisor(dto.razonSocialEmisor());
        entity.setFechaEmision(dto.fechaEmision());
        entity.setFechaRecepcion(dto.fechaRecepcion());
        entity.setMontoNeto(dto.montoNeto().amount()); // Asumiendo que Money tiene .amount()
        entity.setMontoIva(dto.montoIva().amount());
        entity.setMontoTotal(dto.montoTotal().amount());
        entity.setEstado(dto.estado());
        entity.setOrigen("SII_SYNC");
        return entity;
    }
}
Â¿QuÃ© acabamos de lograr?
Persistencia Robusta: Tus facturas ya no viven en memoria. Viven en invoicing.invoices.

Idempotencia: Si le das "Sincronizar" 10 veces, no tendrÃ¡s 10 copias de la misma factura gracias al check existsBy....

Seguridad Multi-tenant: El Controller extrae el CompanyId del token. Un usuario de la Empresa A jamÃ¡s verÃ¡ las facturas de la Empresa B, porque el repository filtra por companyId.

La belleza de tu Arquitectura Orientada a Eventos es que no tienes que elegir. Cuando una factura se guarda, el sistema grita: "Â¡LlegÃ³ una factura!".

El mÃ³dulo de Contabilidad escucha y dice: "Perfecto, creo el asiento contable".

El mÃ³dulo de IA dice: "Entendido, ya tengo data fresca para responder preguntas".

Vamos a implementar el Evento Puente, luego el Listener Contable y finalmente la Herramienta de IA.

Paso 1: El Puente (El Evento de Dominio)
Primero, definimos el mensaje que viaja entre mÃ³dulos. Este evento se dispara justo despuÃ©s de que la factura se guarda en PostgreSQL.

Archivo: src/main/java/com/tuempresa/erp/modules/invoicing/domain/event/InvoiceReceivedEvent.java

Java

package com.tuempresa.erp.modules.invoicing.domain.event;

import com.tuempresa.erp.shared.domain.event.DomainEvent;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.shared.domain.valueobject.Money;
import java.time.Instant;
import java.time.LocalDate;
import java.util.UUID;

// Un Record inmutable que transporta lo que pasÃ³
public class InvoiceReceivedEvent implements DomainEvent {
    private UUID eventId = UUID.randomUUID();
    private Instant occurredAt = Instant.now();
    private CompanyId companyId;
    private String userId; // QuiÃ©n disparÃ³ la sincronizaciÃ³n

    // Datos del negocio
    public final UUID invoiceId;
    public final String rutEmisor;
    public final String razonSocial;
    public final LocalDate fechaEmision;
    public final Money montoTotal;
    public final Money montoIva;

    public InvoiceReceivedEvent(CompanyId companyId, UUID invoiceId, String rutEmisor, 
                                String razonSocial, LocalDate fechaEmision, 
                                Money montoTotal, Money montoIva) {
        this.companyId = companyId;
        this.invoiceId = invoiceId;
        this.rutEmisor = rutEmisor;
        this.razonSocial = razonSocial;
        this.fechaEmision = fechaEmision;
        this.montoTotal = montoTotal;
        this.montoIva = montoIva;
    }

    // ImplementaciÃ³n de mÃ©todos de la interfaz DomainEvent...
    @Override public UUID getEventId() { return eventId; }
    @Override public void setEventId(UUID id) { this.eventId = id; }
    @Override public Instant getOccurredAt() { return occurredAt; }
    @Override public void setOccurredAt(Instant at) { this.occurredAt = at; }
    @Override public CompanyId getCompanyId() { return companyId; }
    @Override public void setCompanyId(CompanyId id) { this.companyId = id; }
    @Override public String getUserId() { return userId; }
    @Override public void setUserId(String id) { this.userId = id; }
}
Nota: Debes publicar este evento en tu InvoiceController o RcvDownloadService justo despuÃ©s de repository.save().

Paso 2: Contabilidad AutomÃ¡tica (El Robot Contable)
Este listener vive en el mÃ³dulo accounting. Su trabajo es traducir "Factura" a "Asiento Contable" (Debe/Haber).

LÃ³gica Contable Simplificada:

Debe: Cuenta de Gasto (o Activo) + Cuenta IVA CrÃ©dito Fiscal.

Haber: Cuenta Proveedores (Pasivo).

Archivo: src/main/java/com/tuempresa/erp/modules/accounting/application/listener/InvoiceAccountingListener.java

Java

package com.tuempresa.erp.modules.accounting.application.listener;

import com.tuempresa.erp.modules.accounting.domain.model.AccountingEntry;
import com.tuempresa.erp.modules.accounting.domain.port.in.PostEntryUseCase;
import com.tuempresa.erp.modules.invoicing.domain.event.InvoiceReceivedEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.scheduling.annotation.Async;
import org.springframework.stereotype.Component;
import org.springframework.transaction.event.TransactionPhase;
import org.springframework.transaction.event.TransactionalEventListener;

import java.math.BigDecimal;

@Component
public class InvoiceAccountingListener {

    private static final Logger log = LoggerFactory.getLogger(InvoiceAccountingListener.class);
    private final PostEntryUseCase postEntryUseCase;

    public InvoiceAccountingListener(PostEntryUseCase postEntryUseCase) {
        this.postEntryUseCase = postEntryUseCase;
    }

    /**
     * Reacciona cuando llega una factura nueva.
     * Se ejecuta en un Virtual Thread separado, pero CON el contexto de la empresa (ScopedValue).
     */
    @Async
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
    public void onInvoiceReceived(InvoiceReceivedEvent event) {
        log.info("Generando asiento contable automÃ¡tico para factura de: {}", event.razonSocial);

        // 1. Determinar cuentas (En un sistema real, esto viene de una configuraciÃ³n por proveedor)
        String cuentaGasto = "4-10-10"; // Gastos Generales
        String cuentaIva = "1-10-50";   // IVA CrÃ©dito Fiscal
        String cuentaPasivo = "2-10-10"; // Proveedores Nacionales

        // 2. Calcular montos
        BigDecimal total = event.montoTotal.amount();
        BigDecimal iva = event.montoIva.amount();
        BigDecimal neto = total.subtract(iva);

        // 3. Crear el Asiento (Entry)
        AccountingEntry entry = new AccountingEntry();
        entry.setCompanyId(event.getCompanyId().value());
        entry.setFecha(event.fechaEmision);
        entry.setGlosa("Compra automÃ¡tica SII - Fac: " + event.razonSocial);
        
        // DEBE: Gasto + IVA
        entry.addLine(cuentaGasto, neto, BigDecimal.ZERO); 
        entry.addLine(cuentaIva, iva, BigDecimal.ZERO);
        
        // HABER: Deuda Proveedor
        entry.addLine(cuentaPasivo, BigDecimal.ZERO, total);

        // 4. Guardar en Libro Diario
        postEntryUseCase.post(entry);
        
        log.info("Asiento generado con Ã©xito.");
    }
}
Paso 3: IA - La Herramienta de Consulta (El Cerebro)
Ahora habilitamos a la IA para que pueda "ver" estas facturas. Usaremos LangChain4j. La IA no accede a la base de datos directamente con SQL (peligroso), sino a travÃ©s de una "Herramienta" (Tool) segura.

Archivo: src/main/java/com/tuempresa/erp/modules/ai_assistant/application/tools/SearchInvoicesTool.java

Java

package com.tuempresa.erp.modules.ai_assistant.application.tools;

import com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.entity.InvoiceEntity;
import com.tuempresa.erp.modules.invoicing.infrastructure.adapter.out.persistence.repository.InvoiceJpaRepository;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import dev.langchain4j.agent.tool.Tool;
import org.springframework.stereotype.Component;

import java.time.LocalDate;
import java.util.List;
import java.util.UUID;
import java.util.stream.Collectors;

@Component
public class SearchInvoicesTool {

    private final InvoiceJpaRepository repository;

    public SearchInvoicesTool(InvoiceJpaRepository repository) {
        this.repository = repository;
    }

    /**
     * Esta anotaciÃ³n @Tool es la magia. 
     * La descripciÃ³n le dice al LLM CUÃNDO y CÃ“MO usar esta funciÃ³n Java.
     */
    @Tool("Busca facturas de proveedores por rango de fechas. Retorna lista detallada.")
    public String searchInvoices(String startDate, String endDate) {
        try {
            // 1. Obtener contexto de seguridad (Multi-tenant)
            UUID companyId = CompanyContext.requireCompanyId().value();
            
            // 2. Parsear fechas (La IA suele enviar YYYY-MM-DD)
            LocalDate start = LocalDate.parse(startDate);
            LocalDate end = LocalDate.parse(endDate);

            // 3. Consultar DB
            List<InvoiceEntity> invoices = repository.findByCompanyIdAndFechaEmisionBetween(
                companyId, start, end
            );

            if (invoices.isEmpty()) {
                return "No se encontraron facturas en ese rango de fechas.";
            }

            // 4. Formatear respuesta para que la IA la entienda mejor (CSV o JSON ligero)
            // Ahorramos tokens no enviando todos los campos tÃ©cnicos
            return invoices.stream()
                .map(inv -> String.format(
                    "Emisor: %s, Fecha: %s, Total: $%s, IVA: $%s",
                    inv.getRazonSocialEmisor(),
                    inv.getFechaEmision(),
                    inv.getMontoTotal(),
                    inv.getMontoIva()
                ))
                .collect(Collectors.joining("\n"));

        } catch (Exception e) {
            return "Error buscando facturas: " + e.getMessage();
        }
    }
}
Â¿CÃ³mo se ve esto en acciÃ³n?
Imagina este flujo real que acabas de construir:

Trigger: El Cron Job nocturno (o tÃº manual) ejecuta syncWithSii().

Persistencia: Se guardan 50 facturas en PostgreSQL.

Evento: Se disparan 50 eventos InvoiceReceivedEvent en paralelo (Virtual Threads).

Contabilidad: Casi instantÃ¡neamente, aparecen 50 asientos en tu Libro Diario (accounting.journal_entries).

Usuario: Abre el chat y pregunta: "Â¿CuÃ¡nto gastamos en proveedores la semana pasada?"

IA:

Analiza la pregunta.

Decide ejecutar SearchInvoicesTool("2025-11-24", "2025-12-01").

Tu cÃ³digo Java busca en PostgreSQL.

La IA recibe el texto, suma los montos y responde: "Gastaste un total de $1.500.000 en 12 facturas, principalmente con AWS y Google Cloud".

Cerremos este ciclo.

AquÃ­ es donde tu arquitectura brilla. Vamos a exponer un endpoint que parece simple (POST /chat), pero que por detrÃ¡s orquesta:

Seguridad (Contexto de Empresa vÃ­a ScopedValue).

LLM (El cerebro que entiende la intenciÃ³n).

Tools (Tu cÃ³digo Java que consulta la DB).

Virtual Threads (Para manejar la espera del LLM sin bloquear).

Implementaremos esto usando LangChain4j, que es el estÃ¡ndar actual para Java + AI.

1. El DTO (Contrato de Datos)
Simple y directo.

src/main/java/com/tuempresa/erp/modules/ai_assistant/application/dto/ChatRequestDTO.java

Java

package com.tuempresa.erp.modules.ai_assistant.application.dto;

public record ChatRequestDTO(
    String message // Ej: "Â¿CuÃ¡nto gastamos en AWS el mes pasado?"
) {}

public record ChatResponseDTO(
    String answer // Ej: "EncontrÃ© 3 facturas de AWS por un total de $450.000..."
) {}
2. La Interfaz del Asistente (The AI Service)
En LangChain4j, defines una interfaz y la librerÃ­a genera la implementaciÃ³n (el Proxy) que conecta con OpenAI/Claude y ejecuta las herramientas automÃ¡ticamente.

src/main/java/com/tuempresa/erp/modules/ai_assistant/domain/service/FinancialAssistant.java

Java

package com.tuempresa.erp.modules.ai_assistant.domain.service;

import dev.langchain4j.service.SystemMessage;

// Esta interfaz es mÃ¡gica. LangChain4j crearÃ¡ la implementaciÃ³n en tiempo de ejecuciÃ³n.
public interface FinancialAssistant {

    @SystemMessage("""
        Eres un Asistente Contable Experto para empresas chilenas.
        
        Tus responsabilidades:
        1. Responder preguntas sobre finanzas, facturas y contabilidad.
        2. USAR SIEMPRE las herramientas disponibles para buscar datos reales. No inventes nÃºmeros.
        3. Si la herramienta devuelve datos, analÃ­zalos y resume la respuesta para el usuario.
        4. Si no encuentras datos, dilo honestamente.
        
        El usuario NO es tÃ©cnico, hÃ¡blale en tÃ©rminos de negocio (Flujo de caja, gastos, proveedores).
        """)
    String chat(String userMessage);
}
3. La ConfiguraciÃ³n (El Cableado)
AquÃ­ conectamos el modelo (OpenAI), la memoria (Historial de chat) y tus herramientas (SearchInvoicesTool).

src/main/java/com/tuempresa/erp/modules/ai_assistant/infrastructure/config/AiConfig.java

Java

package com.tuempresa.erp.modules.ai_assistant.infrastructure.config;

import com.tuempresa.erp.modules.ai_assistant.application.tools.SearchInvoicesTool;
import com.tuempresa.erp.modules.ai_assistant.domain.service.FinancialAssistant;
import dev.langchain4j.memory.chat.MessageWindowChatMemory;
import dev.langchain4j.model.chat.ChatLanguageModel;
import dev.langchain4j.model.openai.OpenAiChatModel;
import dev.langchain4j.service.AiServices;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

@Configuration
public class AiConfig {

    @Value("${openai.api-key}")
    private String openAiApiKey;

    /**
     * 1. Definimos el modelo (Cerebro).
     * Usamos GPT-4o o GPT-4o-mini por su capacidad de llamar Tools (Function Calling).
     */
    @Bean
    public ChatLanguageModel chatLanguageModel() {
        return OpenAiChatModel.builder()
                .apiKey(openAiApiKey)
                .modelName("gpt-4o") 
                .temperature(0.0) // 0.0 para ser precisos y analÃ­ticos, no creativos
                .timeout(Duration.ofSeconds(60))
                .build();
    }

    /**
     * 2. Construimos el Asistente inyectando tus Tools de Java.
     */
    @Bean
    public FinancialAssistant financialAssistant(
            ChatLanguageModel chatLanguageModel,
            SearchInvoicesTool searchInvoicesTool // Â¡Tu herramienta del paso anterior!
    ) {
        return AiServices.builder(FinancialAssistant.class)
                .chatLanguageModel(chatLanguageModel)
                .tools(searchInvoicesTool) // AquÃ­ le damos "poderes" a la IA
                .chatMemory(MessageWindowChatMemory.withMaxMessages(10)) // Memoria a corto plazo
                .build();
    }
}
4. El Controller (El Endpoint Final)
Finalmente, exponemos el servicio. Gracias a Java 25 y Virtual Threads, este endpoint puede recibir miles de peticiones simultÃ¡neas. Aunque el LLM tarde 5 segundos en responder, el servidor no se bloquerÃ¡.

src/main/java/com/tuempresa/erp/modules/ai_assistant/infrastructure/adapter/in/rest/AiAssistantController.java

Java

package com.tuempresa.erp.modules.ai_assistant.infrastructure.adapter.in.rest;

import com.tuempresa.erp.modules.ai_assistant.application.dto.ChatRequestDTO;
import com.tuempresa.erp.modules.ai_assistant.application.dto.ChatResponseDTO;
import com.tuempresa.erp.modules.ai_assistant.domain.service.FinancialAssistant;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/v1/ai")
public class AiAssistantController {

    private static final Logger log = LoggerFactory.getLogger(AiAssistantController.class);
    private final FinancialAssistant assistant;

    public AiAssistantController(FinancialAssistant assistant) {
        this.assistant = assistant;
    }

    @PostMapping("/chat")
    public ResponseEntity<ChatResponseDTO> chat(@RequestBody ChatRequestDTO request) {
        // 1. Verificar seguridad y contexto
        var companyId = CompanyContext.requireCompanyId();
        var userId = CompanyContext.getUserId().orElse("anonymous");

        log.info("AI Chat Request | Company: {} | User: {} | Msg: {}", 
                 companyId, userId, request.message());

        // 2. Llamar al asistente (La magia ocurre aquÃ­)
        // El ScopedValue (CompanyContext) se propaga automÃ¡ticamente si el asistente
        // usa hilos internos, pero como usamos sync en Virtual Threads, es directo.
        String response = assistant.chat(request.message());

        // 3. Retornar respuesta
        return ResponseEntity.ok(new ChatResponseDTO(response));
    }
}
ğŸ‰ El Ciclo Completo en AcciÃ³n
Imagina que ejecutas esto ahora mismo. AsÃ­ es como fluye la informaciÃ³n a travÃ©s de tu arquitectura "Senior":

Frontend: EnvÃ­a POST /api/v1/ai/chat

JSON

{ "message": "Â¿CuÃ¡nto gastamos con 'Entel' en diciembre 2025?" }
Controller: Recibe el request. SecurityFilter ya inyectÃ³ el CompanyId en el ScopedValue. Llama a assistant.chat().

LangChain4j (Agente):

Lee el mensaje del usuario.

Lee la definiciÃ³n de @Tool en SearchInvoicesTool.

Razona: "Necesito buscar facturas. El usuario dijo 'Entel' y 'diciembre 2025'. Voy a llamar a la funciÃ³n searchInvoices con fechas 2025-12-01 a 2025-12-31".

Java (SearchInvoicesTool):

Se ejecuta tu mÃ©todo searchInvoices.

Extrae CompanyContext (Contexto seguro).

Ejecuta invoiceRepository.findByCompanyIdAndFechaEmisionBetween(...).

PostgreSQL retorna 2 facturas.

Java retorna: "Emisor: Entel PCS, Total: $50.000... Emisor: Entel Hogar, Total: $30.000".

LangChain4j (LLM):

Recibe los datos crudos.

Genera lenguaje natural: "En diciembre de 2025, la empresa gastÃ³ un total de $80.000 con Entel, divididos en dos facturas...".

Response: El usuario ve la respuesta inteligente en < 3 segundos.

ConclusiÃ³n del Proyecto
Has diseÃ±ado e implementado:

IntegraciÃ³n Legacy: ConexiÃ³n SOAP/XMLDSig robusta con el SII.

Arquitectura Escalable: Modular Monolith con Eventos.

TecnologÃ­a de Punta: Java 25, Virtual Threads, ScopedValues.

Inteligencia Artificial: Agentes con capacidad de consultar tu propia base de datos (RAG/Tool Use).

Tienes toda la razÃ³n. Aunque en el paso anterior incluimos un InvoiceController en el mÃ³dulo de facturaciÃ³n, para "ver la magia" y mantener la arquitectura limpia, necesitamos un Controller Operativo en el mÃ³dulo de integraciÃ³n (integration_sii).

Este controller servirÃ¡ para probar la conexiÃ³n en tiempo real ("Raw Data") sin pasar por la base de datos local. Es ideal para depurar quÃ© estÃ¡ respondiendo exactamente el SII.

Controller de Operaciones SII
Este componente expone la capacidad de "hablar" con el SII directamente.

Archivo: src/main/java/com/tuempresa/erp/modules/integration_sii/infrastructure/adapter/in/rest/SiiOperationsController.java

Java

package com.tuempresa.erp.modules.integration_sii.infrastructure.adapter.in.rest;

import com.tuempresa.erp.modules.integration_sii.domain.model.RcvInvoiceSummary;
import com.tuempresa.erp.modules.integration_sii.domain.service.RcvDownloadService;
import com.tuempresa.erp.modules.integration_sii.domain.service.SiiAuthenticationService;
import com.tuempresa.erp.shared.domain.valueobject.CompanyId;
import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;

@RestController
@RequestMapping("/api/v1/sii/ops")
public class SiiOperationsController {

    private final SiiAuthenticationService authService;
    private final RcvDownloadService rcvService;

    public SiiOperationsController(SiiAuthenticationService authService, RcvDownloadService rcvService) {
        this.authService = authService;
        this.rcvService = rcvService;
    }

    /**
     * Endpoint de DiagnÃ³stico: Probar AutenticaciÃ³n (Handshake)
     * GET /api/v1/sii/ops/check-auth
     * * Retorna el Token actual si funciona, para verificar que certificados y firmas estÃ¡n OK.
     */
    @GetMapping("/check-auth")
    public ResponseEntity<?> checkAuth() {
        CompanyId companyId = CompanyContext.requireCompanyId();
        try {
            // Esto fuerza el handshake completo: Seed -> Sign -> Token
            String token = authService.getValidToken(companyId);
            return ResponseEntity.ok(Map.of(
                "status", "SUCCESS",
                "message", "AutenticaciÃ³n con SII exitosa",
                "token", token.substring(0, 10) + "..." // Por seguridad no mostrar entero
            ));
        } catch (Exception e) {
            return ResponseEntity.internalServerError().body(Map.of(
                "status", "ERROR",
                "message", "Fallo en autenticaciÃ³n SII: " + e.getMessage()
            ));
        }
    }

    /**
     * Endpoint de OperaciÃ³n: Descarga Manual RCV
     * POST /api/v1/sii/ops/fetch-rcv?rut=76123123-4&periodo=202512
     * * Va al SII en tiempo real y devuelve el JSON crudo de lo que encontrÃ³.
     * Ideal para ver "la magia" en el navegador.
     */
    @PostMapping("/fetch-rcv")
    public ResponseEntity<List<RcvInvoiceSummary>> fetchRcvRaw(
            @RequestParam String rutEmpresa,
            @RequestParam String periodo
    ) {
        CompanyId companyId = CompanyContext.requireCompanyId();
        
        // Llama al servicio que construimos antes
        // Esto desencadena: SOAP -> Parser -> Java Objects
        List<RcvInvoiceSummary> data = rcvService.syncPurchases(companyId, rutEmpresa, periodo);
        
        return ResponseEntity.ok(data);
    }
}
ğŸ§ª CÃ³mo ver "La Magia" funcionando (Prueba Real)
Como aÃºn no tienes el Frontend en React/Vue, usaremos cURL (o Postman) para simular al navegador.

Paso 1: AutentÃ­cate en tu API (Login ficticio para obtener JWT)
Asumimos que ya tienes el endpoint de login del mÃ³dulo SSO funcionando o deshabilitaste la seguridad temporalmente para dev.

Paso 2: Ver los datos del SII en vivo
Ejecuta esto en tu terminal. Esto viajarÃ¡ a tu backend Java, este firmarÃ¡ digitalmente, irÃ¡ a palena.sii.cl, volverÃ¡, parsearÃ¡ el XML y te darÃ¡ JSON.

Bash

curl -X POST "http://localhost:8080/api/v1/sii/ops/fetch-rcv?rut=76XXXXXX-X&periodo=202512" \
     -H "Authorization: Bearer TU_JWT_TOKEN"
Respuesta JSON esperada (La Magia âœ¨):

JSON

[
  {
    "tipoDte": 33,
    "folio": 10543,
    "rutEmisor": "96999888-0",
    "razonSocialEmisor": "AMAZON WEB SERVICES",
    "fechaEmision": "2025-12-01",
    "montoTotal": 150000,
    "montoIva": 23950,
    "montoNeto": 126050,
    "estado": "REGISTRO"
  },
  {
    "tipoDte": 34,
    "folio": 8821,
    "rutEmisor": "76000111-K",
    "razonSocialEmisor": "ENTEL PCS TELECOMUNICACIONES",
    "fechaEmision": "2025-12-03",
    "montoTotal": 45990,
    "montoIva": 0,
    "montoNeto": 45990,
    "estado": "REGISTRO"
  }
]
Resumen del logro arquitectÃ³nico
Con este Ãºltimo Controller, has completado el Vertical Slice (Corte Vertical) completo:

Capa Externa (API): SiiOperationsController recibe la peticiÃ³n HTTP.

Capa AplicaciÃ³n: RcvDownloadService orquesta la peticiÃ³n.

Capa Dominio: RcvInvoiceSummary define la estructura de datos.

Capa Infraestructura:

SiiAuthenticationService maneja certificados y firmas.

SiiRcvSoapClient maneja el protocolo SOAP legacy.

RcvXmlParser transforma el XML complejo.

Este docker-compose.yml no es uno bÃ¡sico; estÃ¡ configurado para un entorno de desarrollo robusto que soporta:

IA: PostgreSQL con la extensiÃ³n pgvector preinstalada.

Performance: Redis para el cachÃ© de tokens del SII.

Java 25: ConfiguraciÃ³n explÃ­cita para habilitar Preview Features (Virtual Threads/ScopedValues) en el contenedor.

1. El Dockerfile (Para Java 25)
Crea un archivo llamado Dockerfile en la raÃ­z de tu proyecto. Nota: Usamos una imagen que soporte Java 25 (en este escenario futuro, Eclipse Temurin o OpenJDK).

Dockerfile

# Etapa 1: Build con Gradle
FROM gradle:8.10-jdk25 AS builder
WORKDIR /app
COPY . .
# Compilamos habilitando preview features
RUN gradle build --no-daemon -x test

# Etapa 2: Runtime (Imagen ligera)
FROM eclipse-temurin:25-jre-alpine
WORKDIR /app
COPY --from=builder /app/build/libs/*.jar app.jar

# ConfiguraciÃ³n Regional (Chile es vital para el SII)
ENV TZ=America/Santiago
RUN ln -snf /usr/share/zoneinfo/$TZ /etc/localtime && echo $TZ > /etc/timezone

# JVM Flags:
# --enable-preview: OBLIGATORIO para ScopedValues y Virtual Threads
# -XX:+UseZGC: Garbage Collector de baja latencia (ideal para websockets/eventos)
ENTRYPOINT ["java", "--enable-preview", "-XX:+UseZGC", "-jar", "app.jar"]
2. El docker-compose.yml
Crea este archivo en la raÃ­z. He configurado la base de datos para que inicialice automÃ¡ticamente la extensiÃ³n vectorial.

YAML

services:
  # 1. Base de Datos (PostgreSQL + pgvector)
  postgres:
    image: pgvector/pgvector:pg17  # Imagen oficial con vector extension
    container_name: sii_erp_db
    environment:
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password123
      POSTGRES_DB: sii_erp
      TZ: America/Santiago
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      # Script de inicializaciÃ³n para crear esquemas si Flyway falla o para dev rÃ¡pido
      - ./docker/init-db:/docker-entrypoint-initdb.d
    networks:
      - erp-network
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 5s
      timeout: 5s
      retries: 5

  # 2. CachÃ© (Redis)
  redis:
    image: redis:alpine
    container_name: sii_erp_cache
    ports:
      - "6379:6379"
    networks:
      - erp-network
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 3s
      retries: 3

  # 3. Tu AplicaciÃ³n (Spring Boot)
  app:
    build: .
    container_name: sii_erp_app
    ports:
      - "8080:8080"
    environment:
      # ConexiÃ³n DB
      SPRING_DATASOURCE_URL: jdbc:postgresql://postgres:5432/sii_erp
      SPRING_DATASOURCE_USERNAME: postgres
      SPRING_DATASOURCE_PASSWORD: password123
      
      # ConexiÃ³n Redis
      SPRING_DATA_REDIS_HOST: redis
      SPRING_DATA_REDIS_PORT: 6379
      
      # OpenAI (IA) - Pasa esto como variable de entorno al correr docker
      OPENAI_API_KEY: ${OPENAI_API_KEY}
      
      # SII Config (Defaults)
      SII_URL_AUTH: https://palena.sii.cl/DTEWS
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    networks:
      - erp-network

volumes:
  postgres_data:

networks:
  erp-network:
    driver: bridge
3. Instrucciones de Despegue ğŸš€
Para levantar todo el ecosistema, sigue estos pasos en tu terminal:

Paso 1: Exportar tu API Key de OpenAI (Temporalmente)

Bash

export OPENAI_API_KEY="sk-tu-api-key-real-aqui"
Paso 2: Construir y Levantar

Bash

docker-compose up --build
Paso 3: Verificar que todo funciona Una vez que veas el log Started ErpApplication in X.XXX seconds, abre otra terminal y prueba el endpoint de operaciones que creamos:

Bash

# Prueba de Fuego (Healthcheck de la API)
curl -v http://localhost:8080/actuator/health
Resumen del Proyecto Finalizado
IvÃ¡n, has completado el diseÃ±o de una arquitectura de software de clase mundial. Repasemos lo que tienes en este repositorio imaginario:

Core: Java 25 con Virtual Threads (Alta concurrencia nativa).

Arquitectura: Modular Monolith con Event-Driven Design.

Seguridad: Multi-tenancy real usando ScopedValue (Estado del arte en Java).

IntegraciÃ³n: Cliente SOAP con firma digital XMLDSig manual (Nivel Hardcore).

Datos: Persistencia JPA optimizada y PGVector para IA.

IA: Agente capaz de usar Tools Java para consultar tu base de datos.



NOTA:

Â¡Claro que sÃ­\! Estas reglas son vitales para llevar el proyecto a un nivel profesional "Production-Ready".

AquÃ­ tienes los bloques de texto formateados exactamente para encajar en la estructura de tu archivo `Contexto ERP casrusil.txt`. He indicado en quÃ© secciÃ³n especÃ­fica debes pegar cada uno.

### 1\. ActualizaciÃ³n para `AI_CONTEXT.md` (SecciÃ³n 4)

Agrega estas dos nuevas reglas al final de la **secciÃ³n 4 ("Reglas de ImplementaciÃ³n para la IA")**. Esto asegura que la IA lo trate como una restricciÃ³n arquitectÃ³nica dura desde el principio.

```markdown
### Regla #5: Estrategia de Testing (Mocking SII)
Para tests de integraciÃ³n que no sean "End-to-End" (E2E), estÃ¡ **PROHIBIDO** conectar a `palena.sii.cl`.
* **Herramienta:** Usar `MockWebServer` (OkHttp) para simular las respuestas SOAP XML del SII.
* **Certificados:** No requerir un certificado `.p12` real para tests unitarios; usar un mock de `Pkcs12Handler` o un certificado dummy generado en memoria.

### Regla #6: Logging Estructurado (Observabilidad)
Dado que el sistema es Event-Driven y Multi-tenant, el log debe tener contexto.
* **Formato Obligatorio:** `[Tenant: {companyId}] [TraceID: {traceId}] {mensaje}`.
* **ImplementaciÃ³n:** Configurar `MDC` (Mapped Diagnostic Context) en el `SecurityFilter` para requests HTTP y propagarlo manualmente o vÃ­a aspecto en los `Virtual Threads` asÃ­ncronos.
```

-----

### 2\. ActualizaciÃ³n para `docs/ENVIRONMENT.md` (SecciÃ³n 10)

Agrega este bloque al final de la **secciÃ³n 10 ("Variables de Entorno Documentadas")**, justo despuÃ©s de la tabla de variables crÃ­ticas.

```markdown
## Reglas de CI/CD (GitHub Actions)

Para los pipelines de despliegue automatizado, seguir estas reglas de seguridad estrictas:

1.  **InyecciÃ³n de Secretos:** Las variables sensibles NUNCA deben estar escritas en `application.yml` ni en el cÃ³digo. Deben inyectarse como **GitHub Secrets** en tiempo de build/deploy.
    * `SII_CERT_PASSWORD` -> `${{ secrets.SII_CERT_PASSWORD }}`
    * `OPENAI_API_KEY` -> `${{ secrets.OPENAI_API_KEY }}`
    * `JWT_SECRET` -> `${{ secrets.JWT_SECRET }}`
    * `SPRING_DATASOURCE_PASSWORD` -> `${{ secrets.DB_PASSWORD }}`

2.  **Certificados en CI:** El archivo `.p12` de prueba no debe subirse al repo si es real. Para CI, usar un certificado dummy base64 inyectado como secreto y decodificado en un paso del workflow.
```

-----

### 3\. ActualizaciÃ³n para `AI_ASSISTANT_INSTRUCTIONS.md` (Checklist Final)

Para reforzar el testing, agrega esta lÃ­nea al **Checklist Final -\> Antes de Tocar CÃ³digo**:

```markdown
- [ ] Verificar si el cambio requiere conexiÃ³n al SII. Si es asÃ­, Â¿tengo listo el MockWebServer para el test?
```

### Â¿CÃ³mo quedarÃ­a el flujo con estos cambios?

Con estos agregados, cuando le pidas a la IA que "cree un test para la descarga de facturas", ella sabrÃ¡ automÃ¡ticamente que:

1.  No debe intentar hacer un `new SiiRcvSoapClient()` que apunte a internet.
2.  Debe levantar un servidor mock que devuelva el XML que definimos en los ejemplos.
3.  Si falla algo, debe buscar en los logs el `[Tenant: ...]` para saber de quÃ© empresa fue el error.

Vamos a implementar la GeneraciÃ³n de Excel bajo demanda con la IA.

Paso 1: Agregar Dependencias (Apache POI)
Necesitamos la librerÃ­a estÃ¡ndar de la industria para manipular documentos Office en Java.

Archivo: build.gradle.kts Agrega esto a la secciÃ³n dependencies:

Kotlin

// GeneraciÃ³n de Excel
implementation("org.apache.poi:poi-ooxml:5.2.5")
Paso 2: El Generador de Excel (Infraestructura)
Crearemos un servicio genÃ©rico en el mÃ³dulo shared o accounting que tome datos y devuelva un array de bytes (byte[]) con el Excel.

Archivo: src/main/java/com/tuempresa/erp/modules/accounting/infrastructure/reporting/ExcelReportGenerator.java

Java

package com.tuempresa.erp.modules.accounting.infrastructure.reporting;

import com.tuempresa.erp.modules.accounting.application.dto.BalanceSheetDTO;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.springframework.stereotype.Component;

import java.io.ByteArrayOutputStream;
import java.io.IOException;

@Component
public class ExcelReportGenerator {

    public byte[] generateBalanceSheetExcel(BalanceSheetDTO data) {
        try (Workbook workbook = new XSSFWorkbook()) {
            Sheet sheet = workbook.createSheet("Balance General");
            
            // Estilos
            CellStyle headerStyle = workbook.createCellStyle();
            Font headerFont = workbook.createFont();
            headerFont.setBold(true);
            headerStyle.setFont(headerFont);

            // Crear Encabezados
            Row header = sheet.createRow(0);
            header.createCell(0).setCellValue("Cuenta");
            header.createCell(1).setCellValue("Monto");
            header.getCell(0).setCellStyle(headerStyle);
            header.getCell(1).setCellStyle(headerStyle);

            // Llenar Datos (Ejemplo simplificado)
            int rowNum = 1;
            
            // Activos
            Row rowActivo = sheet.createRow(rowNum++);
            rowActivo.createCell(0).setCellValue("TOTAL ACTIVOS");
            rowActivo.createCell(1).setCellValue(data.totalAssets().doubleValue());

            // Pasivos
            Row rowPasivo = sheet.createRow(rowNum++);
            rowPasivo.createCell(0).setCellValue("TOTAL PASIVOS");
            rowPasivo.createCell(1).setCellValue(data.totalLiabilities().doubleValue());

            // Patrimonio
            Row rowPatrimonio = sheet.createRow(rowNum++);
            rowPatrimonio.createCell(0).setCellValue("PATRIMONIO");
            rowPatrimonio.createCell(1).setCellValue(data.equity().doubleValue());

            // Auto-ajustar columnas
            sheet.autoSizeColumn(0);
            sheet.autoSizeColumn(1);

            // Escribir a bytes
            ByteArrayOutputStream out = new ByteArrayOutputStream();
            workbook.write(out);
            return out.toByteArray();

        } catch (IOException e) {
            throw new RuntimeException("Error generando Excel", e);
        }
    }
}
Paso 3: Controlador de Descargas (Endpoint PÃºblico)
La IA no puede "enviarte" el archivo por el chat socket directamente (bueno, podrÃ­a, pero es complejo). Lo estÃ¡ndar es que la IA genere un link de descarga.

Necesitamos un lugar donde el navegador pueda ir a buscar ese archivo temporal.

Archivo: src/main/java/com/tuempresa/erp/modules/accounting/infrastructure/adapter/in/rest/ReportDownloadController.java

Java

package com.tuempresa.erp.modules.accounting.infrastructure.adapter.in.rest;

import com.tuempresa.erp.shared.infrastructure.context.CompanyContext;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.Map;
import java.util.UUID;
import java.util.concurrent.ConcurrentHashMap;

@RestController
@RequestMapping("/api/v1/reports")
public class ReportDownloadController {

    // Almacenamiento temporal en memoria (En prod usar S3 o MinIO)
    private final Map<String, byte[]> tempFileStorage = new ConcurrentHashMap<>();

    // MÃ©todo interno para que otros servicios guarden el archivo y obtengan un ID
    public String storeReport(byte[] content) {
        String fileId = UUID.randomUUID().toString();
        tempFileStorage.put(fileId, content);
        return fileId;
    }

    @GetMapping("/download/{fileId}")
    public ResponseEntity<byte[]> download(@PathVariable String fileId) {
        // En un caso real, validar que el usuario tenga permiso sobre este archivo
        byte[] content = tempFileStorage.get(fileId);
        
        if (content == null) {
            return ResponseEntity.notFound().build();
        }

        return ResponseEntity.ok()
                .header(HttpHeaders.CONTENT_DISPOSITION, "attachment; filename=\"balance_general.xlsx\"")
                .contentType(MediaType.parseMediaType("application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"))
                .body(content);
    }
}
Paso 4: La Herramienta de IA (GenerateExcelTool)
AquÃ­ ocurre la magia. Le enseÃ±amos a la IA a usar el generador y devolver el link.

Archivo: src/main/java/com/tuempresa/erp/modules/ai_assistant/application/tools/GenerateExcelTool.java

Java

package com.tuempresa.erp.modules.ai_assistant.application.tools;

import com.tuempresa.erp.modules.accounting.application.AccountingFacade; // Tu puerto de entrada
import com.tuempresa.erp.modules.accounting.application.dto.BalanceSheetDTO;
import com.tuempresa.erp.modules.accounting.infrastructure.reporting.ExcelReportGenerator;
import com.tuempresa.erp.modules.accounting.infrastructure.adapter.in.rest.ReportDownloadController;
import dev.langchain4j.agent.tool.Tool;
import org.springframework.stereotype.Component;

@Component
public class GenerateExcelTool {

    private final AccountingFacade accountingFacade;
    private final ExcelReportGenerator excelGenerator;
    private final ReportDownloadController downloadController;

    public GenerateExcelTool(AccountingFacade accountingFacade, 
                             ExcelReportGenerator excelGenerator,
                             ReportDownloadController downloadController) {
        this.accountingFacade = accountingFacade;
        this.excelGenerator = excelGenerator;
        this.downloadController = downloadController;
    }

    @Tool("Genera un archivo Excel (.xlsx) con el Balance General del periodo solicitado. Retorna el link de descarga.")
    public String generateBalanceSheetExcel(int year, int month) {
        try {
            // 1. Obtener los datos crudos (DTO)
            BalanceSheetDTO data = accountingFacade.getBalanceSheet(year, month);
            
            // 2. Convertir a Excel (bytes)
            byte[] excelBytes = excelGenerator.generateBalanceSheetExcel(data);
            
            // 3. Guardar temporalmente y obtener URL
            String fileId = downloadController.storeReport(excelBytes);
            String downloadUrl = "/api/v1/reports/download/" + fileId;
            
            // 4. Responder a la IA con el link
            return "El archivo ha sido generado exitosamente. Link de descarga: " + downloadUrl;
            
        } catch (Exception e) {
            return "Error generando el archivo Excel: " + e.getMessage();
        }
    }
}
Resultado Final: El Flujo de Usuario
Usuario: "CrÃ©ame un Excel con el balance de Diciembre 2025".

IA (LangChain4j):

Detecta la intenciÃ³n.

Llama a GenerateExcelTool(2025, 12).

Backend:

Calcula los nÃºmeros contables.

Apache POI dibuja el Excel en memoria.

Guarda los bytes en un Map temporal.

IA: Recibe el link.

Respuesta Chat: "Â¡Listo! He generado tu balance. Puedes descargarlo aquÃ­: http://localhost:8080/api/v1/reports/download/abc-123".

Usuario: Hace clic y descarga el .xlsx.

En la SecciÃ³n 2: Stack TecnolÃ³gico (Restricciones Duras)Agrega esta lÃ­nea a la lista:Reportes & Excel: Apache POI 5.2.5 (Formato .xlsx OOXML).En la SecciÃ³n 4: Reglas de ImplementaciÃ³n para la IAAgrega la Regla #7:Markdown### Regla #7: GeneraciÃ³n de Archivos y Descargas
La IA **NUNCA** debe intentar enviar binarios (bytes) directamente al chat.
* **PatrÃ³n de ImplementaciÃ³n:**
    1. Generar el archivo en memoria (ByteArrayOutputStream).
    2. Guardar en almacenamiento temporal (`ReportDownloadController`) y obtener un `fileId`.
    3. Retornar al usuario ÃšNICAMENTE el link de descarga: `/api/v1/reports/download/{fileId}`.
* **Power BI:** No generar archivos `.pbix`. Para Power BI, exponer endpoints REST/JSON que el software pueda consumir como "Web Source".
2. ActualizaciÃ³n en docs/AI_TOOLS.md (Nuevo Archivo o SecciÃ³n)Si no has creado este archivo mencionado en el Ã­ndice, crÃ©alo ahora con esta definiciÃ³n:Markdown# Herramientas de IA Disponibles (AI Tools)

## ğŸ“Š Reportes Financieros

### `GenerateExcelTool`
**DescripciÃ³n:** Genera un archivo Excel (.xlsx) fÃ­sico con estados financieros formateados.
**Firma:** `generateBalanceSheetExcel(int year, int month)`
**Retorno:** String (URL de descarga).
**Uso:**
* âœ… "Dame un Excel del balance"
* âœ… "Descargar reporte de gastos"
* âŒ "Muestrame el balance en el chat" (Para esto usar `GetBalanceSheetTool` que devuelve texto).

**Restricciones TÃ©cnicas:**
* Usar `Apache POI` con `SXSSFWorkbook` si se esperan mÃ¡s de 10,000 filas (streaming).
* Aplicar estilos bÃ¡sicos (Negritas en headers) para profesionalismo.
3. ActualizaciÃ³n en docs/DEPENDENCIES.mdAgrega a la tabla de "ConfiguraciÃ³n PROBADA":DependenciaVersiÃ³nJavaNotasApache POI (OOXML)5.2.511+âœ… GeneraciÃ³n Excel nativa4. Nota sobre Power BI (Para docs/decisions/ADR-003-reporting.md)Es bueno tener esto documentado para que la IA sepa por quÃ© no hace archivos de Power BI:Markdown# ADR 003: Estrategia de Reportes (Excel vs Power BI)

## DecisiÃ³n
1. **Para Excel:** GeneraciÃ³n server-side usando Apache POI. El usuario descarga un "snapshot" estÃ¡tico.
2. **Para Power BI:** ExposiciÃ³n de endpoints API REST. Power BI se conecta al API, no le enviamos un archivo.

## RazÃ³n
* Los archivos `.pbix` de Power BI son binarios propietarios complejos y no hay librerÃ­as Java estables para generarlos.
* La filosofÃ­a de Power BI es "Conectarse a datos vivos", no "Abrir archivos estÃ¡ticos exportados".

## ImplementaciÃ³n Futura (Power BI)
Crear endpoints dedicados `/api/v1/bi/*` que devuelvan JSON plano sin paginaciÃ³n (o paginaciÃ³n OData) optimizados para importaciÃ³n masiva.
Con estas notas agregadas, tu "Senior Developer IA" sabrÃ¡ exactamente quÃ© hacer cuando le pidas "Hazme un excel con las ventas de ayer" y no intentarÃ¡ escribir cÃ³digo binario raro en la consola.

TENER ENCONSIDERACION :

# CONTEXTO TÃ‰CNICO COMPLETO - CASRUSIL-SII-ERP-AI

## ğŸ¯ ÃNDICE RÃPIDO
1. [Overview del Sistema](#overview)
2. [Reglas ArquitectÃ³nicas Duras](#reglas-duras)
3. [Estado del Proyecto](#estado)
4. [MÃ³dulos y Responsabilidades](#modulos)
5. [Patrones de CÃ³digo](#patrones)
6. [Troubleshooting RÃ¡pido](#troubleshooting)

---

## 1. OVERVIEW DEL SISTEMA {#overview}

### MisiÃ³n
ERP contable para Chile con integraciÃ³n nativa al SII y asistencia por IA.

### Stack TecnolÃ³gico Core
| CategorÃ­a | TecnologÃ­a | VersiÃ³n | RazÃ³n CrÃ­tica |
|-----------|-----------|---------|---------------|
| **Runtime** | Java | 25 | Virtual Threads + ScopedValue |
| **Build** | Gradle | 8.10+ | Kotlin DSL |
| **Framework** | Spring Boot | 3.4.0 | Compatible Java 25 |
| **Database** | PostgreSQL | 17 | pgvector para IA |
| **Cache** | Redis | 7+ | Tokens SII |
| **IA** | LangChain4j | 0.35.0 | Tools estables |
| **SOAP** | java.net.http | JDK 25 | Sin librerÃ­as pesadas |
| **Crypto** | Apache Santuario | 3.0.4 | XMLDSig SII-compatible |

### Arquitectura Visual
```mermaid
graph TB
    subgraph "External"
        SII[SII Chile SOAP]
        LLM[OpenAI/Claude API]
    end
    
    subgraph "Application Layer"
        API[REST API :8080]
        AI[AI Assistant Chat]
    end
    
    subgraph "Domain Modules"
        SSO[SSO<br/>Auth JWT]
        INT[Integration SII<br/>Certificados+SOAP]
        INV[Invoicing<br/>DTEs]
        ACC[Accounting<br/>Contabilidad]
        AIA[AI Assistant<br/>Tools+RAG]
    end
    
    subgraph "Infrastructure"
        PG[(PostgreSQL<br/>pgvector)]
        RD[(Redis<br/>Cache)]
    end
    
    SII -->|XML Firmado| INT
    INT -->|DtesDownloadedEvent| INV
    INV -->|InvoiceReceivedEvent| ACC
    INV --> AIA
    ACC --> AIA
    API --> SSO
    API --> INV
    API --> ACC
    AI --> AIA
    AIA --> LLM
    SSO --> PG
    INV --> PG
    ACC --> PG
    INT --> RD
```

---

## 2. REGLAS ARQUITECTÃ“NICAS DURAS {#reglas-duras}

### â›” RESTRICCIONES ABSOLUTAS (NUNCA VIOLAR)

#### R1: Multi-Tenancy con ScopedValue
```java
// âœ… CORRECTO - Siempre usar CompanyContext
UUID companyId = CompanyContext.requireCompanyId().value();
repository.findByCompanyId(companyId);

// âŒ PROHIBIDO - Queries sin filtro de empresa
repository.findAll(); // VULNERABILIDAD
```

**PropagaciÃ³n AutomÃ¡tica:**
```java
// En SecurityFilter (configuraciÃ³n una sola vez)
CompanyContext.runInCompanyContext(companyId, userId, () -> {
    filterChain.doFilter(request, response);
    return null;
});

// En cualquier capa posterior (automÃ¡tico)
var id = CompanyContext.requireCompanyId(); // âœ… Funciona en Virtual Threads
```

#### R2: Event-Driven Communication
```java
// âœ… CORRECTO - MÃ³dulos desacoplados
eventPublisher.publish(new InvoiceReceivedEvent(...));

// âŒ PROHIBIDO - Dependencia directa entre mÃ³dulos
accountingService.createEntry(invoice); // Acoplamiento
```

#### R3: Virtual Threads Everywhere
```java
// âœ… ConfiguraciÃ³n Global (VirtualThreadConfig.java)
@Bean
public AsyncTaskExecutor asyncTaskExecutor() {
    return new TaskExecutorAdapter(
        Executors.newVirtualThreadPerTaskExecutor()
    );
}

// âŒ PROHIBIDO - Thread Pools manuales
@Bean ThreadPoolTaskExecutor executor() { ... } // Legacy
```

#### R4: Encoding SII (ISO-8859-1)
```java
// âœ… CRÃTICO para firma XMLDSig
String xml = """
    <?xml version="1.0" encoding="ISO-8859-1"?>
    <getToken>...</getToken>
""";

// âŒ FALLA en SII
String xml = """<?xml version="1.0" encoding="UTF-8"?>...""";
```

#### R5: Idempotencia en Sincronizaciones
```java
// âœ… Check-then-Act
boolean exists = repository.existsByCompanyIdAndRutEmisorAndTipoDteAndFolio(...);
if (!exists) { repository.save(entity); }

// âŒ InserciÃ³n ciega
repository.save(entity); // Duplicados si user hace clic 5 veces
```

---

## 3. ESTADO DEL PROYECTO {#estado}

### âœ… IMPLEMENTADO (Funcional - No modificar sin razÃ³n)
- `shared/CompanyContext.java` - ScopedValue multi-tenant
- `shared/VirtualThreadConfig.java` - Virtual Threads config
- `shared/SpringEventPublisher.java` - Event bus
- `integration_sii/XmlDsigSigner.java` - Firma XMLDSig (certificado SII)
- `integration_sii/SiiAuthSoapClient.java` - Handshake SII
- `integration_sii/SiiRcvSoapClient.java` - Descarga RCV
- `invoicing/InvoiceEntity.java` - Persistencia facturas
- `ai_assistant/SearchInvoicesTool.java` - IA query tool

### âš ï¸ EN DESARROLLO (Completar/Mejorar)
- `integration_sii/SiiOperationsController.java` - Logging mejorable
- `invoicing/DtesDownloadedListener.java` - Manejo errores robusto
- `accounting/InvoiceAccountingListener.java` - Tests pendientes
- `ai_assistant/AiAssistantController.java` - Error handling

### ğŸš§ PENDIENTE (Por implementar)
- `integration_sii/DteSenderService.java` - EmisiÃ³n de DTEs
- `accounting/F29CalculatorService.java` - CÃ¡lculo F29
- `ai_assistant/PgVectorAdapter.java` - RAG con embeddings

### ğŸ”’ CÃ“DIGO CRÃTICO (Requiere aprobaciÃ³n senior)
1. `CompanyContext.java` - Core multi-tenant
2. `XmlDsigSigner.java` - SII rechazarÃ¡ requests si falla
3. `SecurityFilter.java` - Brecha de seguridad potencial
4. `VirtualThreadConfig.java` - Performance crÃ­tica

---

## 4. MÃ“DULOS Y RESPONSABILIDADES {#modulos}

### Shared (Kernel)
**Responsabilidad:** Utilidades compartidas, eventos base, seguridad.

**Entidades Clave:**
- `CompanyId` (ValueObject)
- `Money` (ValueObject)
- `DomainEvent` (Interface)

**Sin dependencias a otros mÃ³dulos.**

---

### SSO (Identity & Access)
**Responsabilidad:** AutenticaciÃ³n JWT, gestiÃ³n usuarios/empresas.

**Entidades:**
- `User`, `Company`, `Role`

**Eventos Publicados:**
- `UserAuthenticatedEvent`

**Puertos:**
```java
interface AuthenticateUserUseCase {
    LoginResponseDTO authenticate(LoginRequestDTO request);
}
```

---

### Integration SII (Legacy Adapter)
**Responsabilidad:** ComunicaciÃ³n SOAP con SII, firma digital.

**Modelos:**
- `SiiCertificate` (Record)
- `RcvInvoiceSummary` (Record)

**Eventos Publicados:**
- `DtesDownloadedEvent` (CrÃ­tico - dispara contabilidad)

**Componentes CrÃ­ticos:**
```java
// Certificados
Pkcs12Handler.load(byte[] p12, String password) â†’ SiiCertificate

// Firma
XmlDsigSigner.signSeed(String seed, SiiCertificate) â†’ String xmlFirmado

// SOAP
SiiAuthSoapClient.getSeed() â†’ String
SiiAuthSoapClient.getToken(seed, cert) â†’ String
SiiRcvSoapClient.downloadPurchases(token, rut, periodo) â†’ String xml
```

---

### Invoicing (GestiÃ³n DTEs)
**Responsabilidad:** Persistencia facturas, parsing XML.

**Entidades:**
- `InvoiceEntity` (JPA)

**Eventos Publicados:**
- `InvoiceReceivedEvent` (Para contabilidad automÃ¡tica)

**Unique Constraint:**
```sql
UNIQUE (company_id, rut_emisor, tipo_dte, folio)
```

---

### Accounting (Contabilidad)
**Responsabilidad:** Libros contables, asientos, reportes fiscales.

**Entidades:**
- `AccountingEntry`
- `ChartOfAccounts`

**Listeners:**
```java
@Async
@TransactionalEventListener(phase = AFTER_COMMIT)
void onInvoiceReceived(InvoiceReceivedEvent event) {
    // Auto-genera asiento Debe/Haber
}
```

---

### AI Assistant
**Responsabilidad:** Chat con LLM, ejecuciÃ³n de Tools.

**Tools Implementadas:**
```java
@Tool("Busca facturas por rango de fechas")
String searchInvoices(String startDate, String endDate);

@Tool("Genera Excel con Balance General")
String generateBalanceSheetExcel(int year, int month);
```

**Arquitectura:**
```
User â†’ AiAssistantController â†’ FinancialAssistant (LangChain4j)
        â†“
    Tool Execution (Java methods)
        â†“
    PostgreSQL Query (con CompanyContext)
```

---

## 5. PATRONES DE CÃ“DIGO {#patrones}

### Template: Nuevo Service
```java
@Service
public class MiService {
    private static final Logger log = LoggerFactory.getLogger(MiService.class);
    
    public void operation() {
        // âœ… SIEMPRE obtener contexto
        var companyId = CompanyContext.requireCompanyId();
        log.debug("Operation for company: {}", companyId);
        
        // LÃ³gica aquÃ­
    }
}
```

### Template: Nuevo Controller
```java
@RestController
@RequestMapping("/api/v1/modulo")
public class MiController {
    
    @GetMapping
    public ResponseEntity<?> list() {
        // âœ… Contexto automÃ¡tico
        var companyId = CompanyContext.requireCompanyId();
        
        // âœ… SIEMPRE filtrar
        var data = repository.findByCompanyId(companyId.value());
        return ResponseEntity.ok(data);
    }
}
```

### Template: Event Listener
```java
@Component
public class MiListener {
    
    @Async
    @TransactionalEventListener(phase = AFTER_COMMIT)
    public void handle(MiEvento event) {
        // âœ… Context disponible (ScopedValue propagation)
        var companyId = CompanyContext.requireCompanyId();
        
        // Procesar evento
    }
}
```

### Template: AI Tool
```java
@Component
public class MiTool {
    
    @Tool("DescripciÃ³n clara de quÃ© hace para el LLM")
    public String ejecutar(String param1, int param2) {
        try {
            // âœ… Seguridad multi-tenant
            UUID companyId = CompanyContext.requireCompanyId().value();
            
            // Query o cÃ¡lculo
            var result = repository.findSomething(companyId, param1);
            
            // âœ… Formato friendly para IA
            return result.stream()
                .map(item -> String.format("Item: %s", item))
                .collect(Collectors.joining("\n"));
                
        } catch (Exception e) {
            return "Error: " + e.getMessage();
        }
    }
}
```

---

## 6. TROUBLESHOOTING RÃPIDO {#troubleshooting}

### SÃ­ntoma: "Invalid Signature" del SII
**Causa:** Encoding UTF-8 vs ISO-8859-1
**Fix:** Verificar `XmlDsigSigner.java` lÃ­nea 42

### SÃ­ntoma: CompanyContext es null
**DiagnÃ³stico:**
```bash
# Verificar JWT contiene companyId
curl -H "Authorization: Bearer TOKEN" localhost:8080/actuator/health
```
**Fix:** Revisar `SecurityFilter` configuraciÃ³n del ScopedValue

### SÃ­ntoma: Virtual Thread no propaga contexto
**DiagnÃ³stico:**
```java
log.debug("Thread: {}", Thread.currentThread());
// Si NO dice "VirtualThread" â†’ problema en VirtualThreadConfig
```
**Fix:** Verificar `@Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)`

### SÃ­ntoma: Queries lentas
**Fix:** Verificar Ã­ndices:
```sql
CREATE INDEX idx_invoices_company_date 
ON invoicing.invoices(company_id, fecha_emision);
```

---

## 7. COMANDOS FRECUENTES

```bash
# Build con preview features
./gradlew build --enable-preview

# Tests
./gradlew test

# Docker
docker-compose up --build

# Healthcheck
curl localhost:8080/actuator/health

# Probar SII
curl -X POST "localhost:8080/api/v1/sii/ops/fetch-rcv?rut=X&periodo=202512" \
  -H "Authorization: Bearer TOKEN"
```

---

## 8. PARA LA IA: CHECKLIST ANTES DE MODIFICAR

- [ ] Â¿El archivo estÃ¡ marcado como âœ… en Estado del Proyecto?
- [ ] Si es cÃ³digo crÃ­tico (ğŸ”’), Â¿tengo justificaciÃ³n?
- [ ] Â¿Las queries filtran por `companyId`?
- [ ] Â¿Los eventos usan `@Async` + `@TransactionalEventListener`?
- [ ] Â¿El encoding del SII es ISO-8859-1?
- [ ] Â¿AgreguÃ© logging estructurado: `[Tenant: {id}] {mensaje}`?
- [ ] Â¿EscribÃ­ el test correspondiente?

---

## 9. DEUDA TÃ‰CNICA CONOCIDA

1. **InvoiceController.mapToEntity()** - Mapper manual â†’ Migrar a MapStruct
2. **XmlDsigSigner encoding** - Hardcoded ISO-8859-1 â†’ Parametrizar
3. **Error Handling Global** - Falta `@ControllerAdvice`
4. **Tests de IntegraciÃ³n** - Solo unitarios â†’ Agregar Testcontainers

---

## 10. VARIABLES DE ENTORNO CRÃTICAS

```bash
# Base de datos
SPRING_DATASOURCE_URL=jdbc:postgresql://localhost:5432/sii_erp
SPRING_DATASOURCE_PASSWORD=secreto

# IA
OPENAI_API_KEY=sk-...

# SII
SII_URL_AUTH=https://palena.sii.cl/DTEWS  # Prod
# SII_URL_AUTH=https://maullin.sii.cl/DTEWS  # Cert

# Certificado (Solo Dev)
SII_TEST_CERT_PATH=/path/to/cert.p12
SII_TEST_CERT_PASSWORD=password
```

**NUNCA commitear:**
- `OPENAI_API_KEY`
- `SPRING_DATASOURCE_PASSWORD`
- `JWT_SECRET`

---

## RECURSOS ADICIONALES

- **ADRs completos:** `docs/decisions/`
- **Glosario fiscal:** `docs/GLOSSARY.md`
- **API Contracts:** `docs/API_CONTRACTS.md`
- **Troubleshooting detallado:** `docs/TROUBLESHOOTING.md`



-------------------------------------------------

# ADR 001: AdopciÃ³n de Virtual Threads (Java 25)

## Estado
âœ… **ACEPTADO** - Implementado en VirtualThreadConfig.java (2025-01)

## Contexto

### Problema
El sistema maneja operaciones I/O bloqueantes intensivas:

1. **SOAP Calls al SII**: 
   - Handshake (getSeed + getToken): ~2-5 segundos
   - Descarga RCV: ~10-30 segundos por periodo
   - EnvÃ­o DTEs: ~3-8 segundos por documento

2. **Event Processing**: 
   - Contabilidad automÃ¡tica reacciona a facturas descargadas
   - MÃºltiples listeners procesando en paralelo

3. **AI Tools**:
   - Consultas a LLM: 3-10 segundos por request
   - EjecuciÃ³n de mÃºltiples tools en secuencia

### Alternativas Evaluadas

#### OpciÃ³n 1: ThreadPoolTaskExecutor (Tradicional)
```java
@Bean
public ThreadPoolTaskExecutor taskExecutor() {
    ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
    executor.setCorePoolSize(50);
    executor.setMaxPoolSize(200);
    executor.setQueueCapacity(500);
    return executor;
}
```

**âŒ Problemas:**
- LÃ­mite duro de ~200 threads concurrentes (OS resources)
- Overhead de context switching (threads del OS)
- CompanyContext requiere TaskDecorator manual:
```java
executor.setTaskDecorator(task -> () -> {
    CompanyId id = CompanyContext.get();
    CompanyContext.set(id);
    task.run();
    CompanyContext.clear();
});
```

#### OpciÃ³n 2: Reactor/WebFlux (Reactive)
```java
Mono.fromCallable(() -> siiClient.getToken())
    .subscribeOn(Schedulers.boundedElastic())
    .flatMap(token -> rcvClient.download(token))
    .subscribe(data -> process(data));
```

**âŒ Problemas:**
- Complejidad extrema para operaciones SOAP sÃ­ncronas
- Curva de aprendizaje alta para el equipo
- "Callback hell" dificulta debugging
- Sobrecarga innecesaria (no hay backpressure real del SII)

#### OpciÃ³n 3: Virtual Threads (Project Loom - Java 21+)
```java
@Bean
public AsyncTaskExecutor asyncTaskExecutor() {
    return new TaskExecutorAdapter(
        Executors.newVirtualThreadPerTaskExecutor()
    );
}
```

---

## DecisiÃ³n

**Usar Virtual Threads exclusivamente** para toda operaciÃ³n asÃ­ncrona:
- HTTP Requests (Tomcat)
- Event Listeners (`@Async`)
- Scheduled Tasks (`@Scheduled`)
- AI Tool Execution

### ConfiguraciÃ³n Implementada

```java
@Configuration
@EnableAsync
@EnableScheduling
public class VirtualThreadConfig {
    
    // 1. Tomcat requests â†’ Virtual Threads
    @Bean
    public TomcatProtocolHandlerCustomizer<?> protocolHandler() {
        return handler -> handler.setExecutor(
            Executors.newVirtualThreadPerTaskExecutor()
        );
    }
    
    // 2. @Async methods â†’ Virtual Threads
    @Bean(TaskExecutionAutoConfiguration.APPLICATION_TASK_EXECUTOR_BEAN_NAME)
    public AsyncTaskExecutor asyncTaskExecutor() {
        return new TaskExecutorAdapter(
            Executors.newVirtualThreadPerTaskExecutor()
        );
    }
    
    // 3. @Scheduled tasks â†’ Virtual Threads
    @Bean
    public AsyncTaskExecutor scheduledTaskExecutor() {
        return new TaskExecutorAdapter(
            Executors.newVirtualThreadPerTaskExecutor()
        );
    }
}
```

---

## Consecuencias

### âœ… Positivas

#### 1. Escalabilidad Ilimitada (PrÃ¡ctica)
**Antes (Platform Threads):**
```
200 requests concurrentes â†’ LÃ­mite alcanzado
Request 201 â†’ En cola (latencia)
```

**Ahora (Virtual Threads):**
```
10,000 requests concurrentes â†’ Sin problema
Cada request en su propio thread "barato"
```

**MediciÃ³n Real (JMeter):**
- 5,000 requests/segundo sostenidos
- Latencia p99 < 500ms
- RAM estable (~2GB para JVM)

#### 2. CÃ³digo Secuencial Simple
**Antes:**
```java
CompletableFuture.supplyAsync(() -> authService.getToken())
    .thenApplyAsync(token -> rcvService.download(token))
    .thenAcceptAsync(data -> invoiceService.save(data))
    .exceptionally(ex -> {
        log.error("Error", ex);
        return null;
    });
```

**Ahora:**
```java
String token = authService.getToken();
List<RcvData> data = rcvService.download(token);
invoiceService.save(data);
```

#### 3. PropagaciÃ³n AutomÃ¡tica de Contexto
**Magia de ScopedValue:**
```java
// SecurityFilter (Thread Principal)
CompanyContext.runInCompanyContext(companyId, userId, () -> {
    eventPublisher.publish(event); // Dispara @Async
    return null;
});

// Listener (Virtual Thread Hijo)
@Async
void onEvent(Event e) {
    var id = CompanyContext.requireCompanyId(); // âœ… Funciona!
}
```

**No requiere:**
- âŒ TaskDecorator
- âŒ ThreadLocal.set() manual
- âŒ try-finally cleanup

#### 4. Debugging Mejorado (Java 25)
```bash
jstack <PID>

# Output:
"VirtualThread-23" #23 daemon
    at SiiAuthSoapClient.getToken(SiiAuthSoapClient.java:45)
    at SiiAuthenticationService.performHandshake(...)
    [Tenant: 123e4567-e89b-12d3-a456-426614174000]
```

### âš ï¸ Negativas (Mitigadas)

#### 1. Requiere Java 25+
**Impacto:** No portable a Java 17 LTS anterior

**MitigaciÃ³n:** 
- Docker con imagen `eclipse-temurin:25-jre`
- Documentado en README como requisito hard

#### 2. Stack Traces MÃ¡s Largos
**Problema:** Virtual threads anidan llamadas

**MitigaciÃ³n:**
```yaml
# application.yml
logging:
  level:
    root: INFO
  pattern:
    console: "%d [%thread] %-5level %logger{36} - %msg%n"
```

#### 3. Incompatibilidad con CÃ³digo Legacy Blocking
**Caso Real:** LibrerÃ­as JDBC antiguas con locks

**MitigaciÃ³n:**
- PostgreSQL driver 42.7.4+ (compatible)
- Redis Jedis 5.2.0 (soporte virtual threads)

---

## ValidaciÃ³n

### Test de Carga (Apache JMeter)

**Escenario:** 10,000 users concurrentes llamando `/api/v1/ai/chat`

**Resultados:**
```
ConfiguraciÃ³n: Virtual Threads
- Throughput: 4,832 req/s
- Latencia Media: 156ms
- Latencia p95: 312ms
- Latencia p99: 487ms
- Errores: 0%
- RAM: 1.8GB (stable)

ConfiguraciÃ³n: ThreadPool (max 200)
- Throughput: 197 req/s
- Latencia Media: 5,234ms
- Latencia p95: 12,456ms
- Errores: 23% (Timeout)
- RAM: 2.1GB (spikes)
```

### Test de PropagaciÃ³n de Contexto

```java
@Test
void virtualThreadsShouldPropagateCompanyContext() {
    UUID companyId = UUID.randomUUID();
    
    CompanyContext.runInCompanyContext(
        new CompanyId(companyId), 
        "test-user",
        () -> {
            // Simular @Async listener en Virtual Thread
            CompletableFuture<UUID> future = CompletableFuture.supplyAsync(
                () -> CompanyContext.requireCompanyId().value()
            );
            
            UUID captured = future.get();
            assertEquals(companyId, captured);
            return null;
        }
    );
}
```

**Resultado:** âœ… Pasa (ScopedValue funciona)

---

## Lecciones Aprendidas

### 1. No Todo Debe Ser Async
```java
// âŒ INNECESARIO - OperaciÃ³n rÃ¡pida
@Async
public void calculateSum(int a, int b) {
    return a + b;
}

// âœ… CORRECTO - I/O bloqueante
@Async
public void downloadLargeFile(String url) {
    httpClient.send(request);
}
```

**Regla:** Si la operaciÃ³n toma < 10ms, NO uses @Async

### 2. Monitoreo de Virtual Threads
```java
// JMX Bean personalizado
@ManagedResource
public class VirtualThreadMonitor {
    
    @ManagedMetric
    public long getVirtualThreadCount() {
        return Thread.getAllStackTraces().keySet().stream()
            .filter(Thread::isVirtual)
            .count();
    }
}
```

### 3. Evitar Pooling Sobre Virtual Threads
```java
// âŒ ANTI-PATTERN
ExecutorService pool = Executors.newFixedThreadPool(100);

// âœ… CORRECTO
ExecutorService vt = Executors.newVirtualThreadPerTaskExecutor();
```

---

## Referencias

- [JEP 444: Virtual Threads](https://openjdk.org/jeps/444)
- [JEP 446: Scoped Values](https://openjdk.org/jeps/446)
- [Spring Boot 3.2+ Virtual Threads Support](https://spring.io/blog/2023/10/12/spring-boot-3-2-0-available-now)
- [Benchmark interno: `docs/benchmarks/virtual-threads-load-test.pdf`]

---

## RevisiÃ³n Futura

**Fecha de RevisiÃ³n:** 2026-01 (1 aÃ±o despuÃ©s)

**MÃ©tricas a Evaluar:**
- [ ] Incidentes de producciÃ³n relacionados con concurrencia
- [ ] Uso de RAM en producciÃ³n (comparar con baseline)
- [ ] Latencia p99 en endpoints crÃ­ticos
- [ ] AdopciÃ³n de Java 25+ en la industria

**Criterios de Re-evaluaciÃ³n:**
- Si Java 25 no es LTS y surge un problema crÃ­tico â†’ Considerar downgrade a Java 21 (sacrificando ScopedValue)
- Si aparece un patrÃ³n reactive maduro para Java â†’ Re-evaluar WebFlux

---

## Aprobadores

- **Arquitecto TÃ©cnico:** [Firma Digital]
- **Tech Lead Backend:** [Firma Digital]
- **DevOps Lead:** [Firma Digital]


# Estrategia de Testing - CASRUSIL-SII-ERP-AI

## ğŸ“‹ Ãndice
1. [PirÃ¡mide de Testing](#piramide)
2. [Testing del SII (Mocking)](#sii-mocking)
3. [Testing Multi-Tenant](#multi-tenant)
4. [Testing de IA/Tools](#ia-tools)
5. [Testing de Eventos](#eventos)
6. [Cobertura MÃ­nima](#cobertura)

---

## 1. PirÃ¡mide de Testing {#piramide}

```
        /\
       /  \        E2E (5%)
      /----\       - Flujos crÃ­ticos completos
     /      \      - Certificado SII real (staging)
    /--------\     
   / INTEGRATION \  IntegraciÃ³n (25%)
  /--------------\ - Testcontainers (PostgreSQL)
 /   UNIT TESTS   \ - MockWebServer (SII)
/------------------\ 
   (70%)           Unit (70%)
                   - LÃ³gica de dominio
                   - Validaciones
                   - Mappers
```

### DistribuciÃ³n por MÃ³dulo

| MÃ³dulo | Unit | Integration | E2E |
|--------|------|-------------|-----|
| shared | 80% | 20% | - |
| sso | 70% | 25% | 5% |
| integration_sii | 60% | 35% | 5% |
| invoicing | 75% | 20% | 5% |
| accounting | 70% | 30% | - |
| ai_assistant | 65% | 30% | 5% |

---

## 2. Testing del SII (Mocking) {#sii-mocking}

### â›” PROHIBICIÃ“N ABSOLUTA
```java
// âŒ NUNCA en tests automÃ¡ticos
@Test
void testRealSii() {
    String token = siiClient.getToken(); // LLAMA A palena.sii.cl
}
```

**Razones:**
- Consume folios reales
- Dependencia de red externa
- Tests lentos (5-10 seg cada uno)
- CI/CD fallarÃ­a sin certificado

---

### âœ… Estrategia: MockWebServer

#### Setup Base (Test Utils)

```java
package com.tuempresa.erp.testutils;

import okhttp3.mockwebserver.MockWebServer;
import okhttp3.mockwebserver.MockResponse;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;

public abstract class SiiMockTest {
    
    protected MockWebServer mockSii;
    protected String mockSiiBaseUrl;
    
    @BeforeEach
    void setupMockSii() throws Exception {
        mockSii = new MockWebServer();
        mockSii.start();
        mockSiiBaseUrl = mockSii.url("/").toString();
    }
    
    @AfterEach
    void teardownMockSii() throws Exception {
        mockSii.shutdown();
    }
    
    protected void enqueueSeedResponse(String semilla) {
        String soapResponse = """
            <?xml version="1.0" encoding="UTF-8"?>
            <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
               <soapenv:Body>
                  <ns:getSeedResponse>
                     <SEMILLA>%s</SEMILLA>
                     <ESTADO>00</ESTADO>
                  </ns:getSeedResponse>
               </soapenv:Body>
            </soapenv:Envelope>
            """.formatted(semilla);
            
        mockSii.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(soapResponse));
    }
    
    protected void enqueueTokenResponse(String token) {
        String soapResponse = """
            <?xml version="1.0" encoding="UTF-8"?>
            <soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
               <soapenv:Body>
                  <ns:getTokenResponse>
                     <TOKEN>%s</TOKEN>
                     <ESTADO>00</ESTADO>
                  </ns:getTokenResponse>
               </soapenv:Body>
            </soapenv:Envelope>
            """.formatted(token);
            
        mockSii.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(soapResponse));
    }
    
    protected void enqueueRcvResponse(String xml) {
        mockSii.enqueue(new MockResponse()
            .setResponseCode(200)
            .setBody(xml));
    }
}
```

#### Test de AutenticaciÃ³n

```java
@SpringBootTest
@TestPropertySource(properties = {
    "sii.url.auth=${sii.mock.url}" // Inyectado dinÃ¡micamente
})
class SiiAuthenticationServiceTest extends SiiMockTest {
    
    @Autowired
    private SiiAuthenticationService authService;
    
    @DynamicPropertySource
    static void configureMockUrl(DynamicPropertyRegistry registry) {
        registry.add("sii.url.auth", () -> mockSiiBaseUrl);
    }
    
    @Test
    void shouldAuthenticateSuccessfully() {
        // Arrange
        enqueueSeedResponse("123456789");
        enqueueTokenResponse("TOKEN_ABC_123");
        
        CompanyId companyId = new CompanyId(UUID.randomUUID());
        
        // Act
        String token = authService.getValidToken(companyId);
        
        // Assert
        assertNotNull(token);
        assertEquals("TOKEN_ABC_123", token);
        
        // Verificar que se llamÃ³ al mock
        assertEquals(2, mockSii.getRequestCount()); // Seed + Token
    }
    
    @Test
    void shouldHandleSiiTimeout() {
        // Arrange - Simular timeout
        mockSii.enqueue(new MockResponse()
            .setSocketPolicy(SocketPolicy.NO_RESPONSE));
        
        // Act & Assert
        assertThrows(SiiTimeoutException.class, () -> {
            authService.getValidToken(new CompanyId(UUID.randomUUID()));
        });
    }
}
```

#### Test de Descarga RCV (Con XML Real del SII)

```java
class RcvDownloadServiceTest extends SiiMockTest {
    
    @Test
    void shouldParseRealSiiXml() {
        // Arrange - XML copiado de respuesta real del SII
        String realRcvXml = """
            <?xml version="1.0" encoding="ISO-8859-1"?>
            <resp>
                <cuerpo>
                    <detalle>
                        <tipoDoc>33</tipoDoc>
                        <folio>12345</folio>
                        <rutEmisor>96999888-0</rutEmisor>
                        <rznsocEmisor>AMAZON WEB SERVICES</rznsocEmisor>
                        <fchEmis>2025-12-01 10:30:00</fchEmis>
                        <mntTotal>150000</mntTotal>
                        <mntIva>23950</mntIva>
                        <mntNeto>126050</mntNeto>
                        <estado>REGISTRO</estado>
                    </detalle>
                </cuerpo>
            </resp>
            """;
        
        enqueueRcvResponse(realRcvXml);
        
        // Act
        List<RcvInvoiceSummary> result = rcvService.syncPurchases(
            companyId, "76123456-7", "202512"
        );
        
        // Assert
        assertEquals(1, result.size());
        
        RcvInvoiceSummary invoice = result.get(0);
        assertEquals(33, invoice.tipoDte());
        assertEquals(12345L, invoice.folio());
        assertEquals("96999888-0", invoice.rutEmisor());
        assertEquals(new Money(150000), invoice.montoTotal());
    }
}
```

---

## 3. Testing Multi-Tenant {#multi-tenant}

### Test Base para Aislamiento

```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
@Testcontainers
class MultiTenantRepositoryTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:17")
        .withDatabaseName("test_erp");
    
    @Autowired
    private InvoiceJpaRepository invoiceRepository;
    
    private UUID companyA = UUID.randomUUID();
    private UUID companyB = UUID.randomUUID();
    
    @BeforeEach
    void setupTestData() {
        // Company A - 2 facturas
        invoiceRepository.save(createInvoice(companyA, "76111111-1", 1001L));
        invoiceRepository.save(createInvoice(companyA, "76222222-2", 1002L));
        
        // Company B - 1 factura
        invoiceRepository.save(createInvoice(companyB, "76333333-3", 2001L));
    }
    
    @Test
    void shouldIsolateDataByCompany() {
        // Act
        List<InvoiceEntity> companyAData = invoiceRepository.findByCompanyId(companyA);
        List<InvoiceEntity> companyBData = invoiceRepository.findByCompanyId(companyB);
        
        // Assert
        assertEquals(2, companyAData.size());
        assertEquals(1, companyBData.size());
        
        // Verificar que NO hay cross-contamination
        companyAData.forEach(invoice -> 
            assertEquals(companyA, invoice.getCompanyId())
        );
    }
    
    @Test
    void shouldPreventDuplicateInvoices() {
        // Arrange - Factura que ya existe
        InvoiceEntity duplicate = createInvoice(companyA, "76111111-1", 1001L);
        
        // Act & Assert
        assertThrows(DataIntegrityViolationException.class, () -> {
            invoiceRepository.save(duplicate);
            invoiceRepository.flush(); // Forzar constraint check
        });
    }
    
    private InvoiceEntity createInvoice(UUID companyId, String rut, Long folio) {
        InvoiceEntity entity = new InvoiceEntity();
        entity.setCompanyId(companyId);
        entity.setRutEmisor(rut);
        entity.setTipoDte(33);
        entity.setFolio(folio);
        entity.setMontoTotal(BigDecimal.valueOf(100000));
        entity.setFechaEmision(LocalDate.now());
        return entity;
    }
}
```

### Test de PropagaciÃ³n de Contexto

```java
@SpringBootTest
class CompanyContextPropagationTest {
    
    @Autowired
    private ApplicationEventPublisher eventPublisher;
    
    @Test
    void shouldPropagateContextToAsyncListeners() throws Exception {
        // Arrange
        UUID companyId = UUID.randomUUID();
        CountDownLatch latch = new CountDownLatch(1);
        AtomicReference<UUID> capturedId = new AtomicReference<>();
        
        // Listener temporal
        @Component
        class TestListener {
            @Async
            @EventListener
            void handle(TestEvent event) {
                capturedId.set(CompanyContext.requireCompanyId().value());
                latch.countDown();
            }
        }
        
        // Act - Ejecutar dentro de contexto
        CompanyContext.runInCompanyContext(
            new CompanyId(companyId),
            "test-user",
            () -> {
                eventPublisher.publishEvent(new TestEvent());
                return null;
            }
        );
        
        // Assert
        assertTrue(latch.await(5, TimeUnit.SECONDS));
        assertEquals(companyId, capturedId.get());
    }
}
```

---

## 4. Testing de IA/Tools {#ia-tools}

### Mock del LLM

```java
@TestConfiguration
class AiTestConfig {
    
    @Bean
    @Primary
    public ChatLanguageModel mockLlm() {
        return new ChatLanguageModel() {
            @Override
            public Response<AiMessage> generate(List<ChatMessage> messages) {
                // Simular respuesta del LLM con tool call
                String toolCall = """
                    {
                        "toolCalls": [{
                            "name": "searchInvoices",
                            "arguments": {
                                "startDate": "2025-12-01",
                                "endDate": "2025-12-31"
                            }
                        }]
                    }
                    """;
                
                return Response.from(AiMessage.from(toolCall));
            }
        };
    }
}
```

### Test de Tool Execution

```java
@SpringBootTest
@Import(AiTestConfig.class)
class SearchInvoicesToolTest {
    
    @Autowired
    private SearchInvoicesTool tool;
    
    @MockBean
    private InvoiceJpaRepository repository;
    
    @Test
    void shouldExecuteToolWithinCompanyContext() {
        // Arrange
        UUID companyId = UUID.randomUUID();
        List<InvoiceEntity> mockData = List.of(
            createMockInvoice("AWS", 150000),
            createMockInvoice("Google", 200000)
        );
        
        when(repository.findByCompanyIdAndFechaEmisionBetween(
            eq(companyId), any(), any()
        )).thenReturn(mockData);
        
        // Act
        String result = CompanyContext.runInCompanyContext(
            new CompanyId(companyId),
            "test-user",
            () -> tool.searchInvoices("2025-12-01", "2025-12-31")
        );
        
        // Assert
        assertTrue(result.contains("AWS"));
        assertTrue(result.contains("150000"));
        assertTrue(result.contains("Google"));
        
        // Verificar que se usÃ³ el companyId correcto
        verify(repository).findByCompanyIdAndFechaEmisionBetween(
            eq(companyId), any(), any()
        );
    }
}
```

---

## 5. Testing de Eventos {#eventos}

### Test de Event Publishing

```java
@SpringBootTest
class EventPublishingTest {
    
    @Autowired
    private EventPublisher eventPublisher;
    
    @Autowired
    private ApplicationEventPublisher springPublisher;
    
    @Test
    void shouldPublishEventWithMetadata() {
        // Arrange
        UUID companyId = UUID.randomUUID();
        AtomicReference<DomainEvent> capturedEvent = new AtomicReference<>();
        
        springPublisher.addApplicationListener(event -> {
            if (event instanceof DomainEvent) {
                capturedEvent.set((DomainEvent) event);
            }
        });
        
        // Act
        CompanyContext.runInCompanyContext(
            new CompanyId(companyId),
            "test-user",
            () -> {
                eventPublisher.publish(new InvoiceReceivedEvent(
                    new CompanyId(companyId),
                    UUID.randomUUID(),
                    "76111111-1",
                    "Test Provider",
                    LocalDate.now(),
                    new Money(100000),
                    new Money(19000)
                ));
                return null;
            }
        );
        
        // Assert
        assertNotNull(capturedEvent.get());
        assertEquals(companyId, capturedEvent.get().getCompanyId().value());
        assertEquals("test-user", capturedEvent.get().getUserId());
        assertNotNull(capturedEvent.get().getEventId());
        assertNotNull(capturedEvent.get().getOccurredAt());
    }
}
```

### Test de Listener Idempotencia

```java
@SpringBootTest
class ListenerIdempotencyTest {
    
    @MockBean
    private AccountingEntryRepository accountingRepo;
    
    @Test
    void shouldHandleEventOnlyOnce() {
        // Arrange
        InvoiceReceivedEvent event = createEvent();
        
        // Act - Publicar 3 veces
        eventPublisher.publish(event);
        eventPublisher.publish(event);
        eventPublisher.publish(event);
        
        await().atMost(2, TimeUnit.SECONDS)
               .untilAsserted(() -> {
                   // Assert - Solo debe crear 1 asiento
                   verify(accountingRepo, times(1)).save(any());
               });
    }
}
```

---

## 6. Cobertura MÃ­nima {#cobertura}

### ConfiguraciÃ³n Jacoco

```kotlin
// build.gradle.kts
plugins {
    id("jacoco")
}

tasks.test {
    finalizedBy(tasks.jacocoTestReport)
}

tasks.jacocoTestReport {
    dependsOn(tasks.test)
    
    reports {
        xml.required.set(true)
        html.required.set(true)
    }
}

tasks.jacocoTestCoverageVerification {
    violationRules {
        rule {
            limit {
                minimum = "0.70".toBigDecimal() // 70% mÃ­nimo
            }
        }
        
        rule {
            element = "CLASS"
            limit {
                counter = "BRANCH"
                minimum = "0.60".toBigDecimal()
            }
            
            excludes = listOf(
                "*.config.*",
                "*.dto.*",
                "*Entity"
            )
        }
    }
}
```

### Targets por MÃ³dulo

| MÃ³dulo | LÃ­neas | Branches | Excluidos |
|--------|--------|----------|-----------|
| shared | 85% | 75% | DTOs, Config |
| sso | 70% | 60% | Entities |
| integration_sii | 65% | 55% | Parsers legacy |
| invoicing | 75% | 65% | Entities |
| accounting | 80% | 70% | - |
| ai_assistant | 65% | 55% | LLM mocks |

---

## 7. CI/CD Integration

### GitHub Actions Workflow

```yaml
name: Tests

on: [push, pull_request]

jobs:
  test:
    runs-on: ubuntu-latest
    
    services:
      postgres:
        image: pgvector/pgvector:pg17
        env:
          POSTGRES_PASSWORD: test
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
      
      redis:
        image: redis:alpine
    
    steps:
      - uses: actions/checkout@v4
      
      - name: Setup Java 25
        uses: actions/setup-java@v4
        with:
          java-version: '25'
          distribution: 'temurin'
      
      - name: Run Tests
        run: ./gradlew test --enable-preview
        env:
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY_TEST }}
      
      - name: Generate Coverage Report
        run: ./gradlew jacocoTestReport
      
      - name: Upload Coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./build/reports/jacoco/test/jacocoTestReport.xml
      
      - name: Verify Coverage
        run: ./gradlew jacocoTestCoverageVerification
```

---

## 8. Comandos Ãštiles

```bash
# Tests completos
./gradlew test

# Tests especÃ­ficos
./gradlew test --tests "SiiAuthenticationServiceTest"

# Tests de integraciÃ³n (requiere Testcontainers)
./gradlew integrationTest

# Coverage report
./gradlew jacocoTestReport
# Ver: build/reports/jacoco/test/html/index.html

# Verificar cobertura mÃ­nima
./gradlew jacocoTestCoverageVerification

# Tests con debug
./gradlew test --debug-jvm

# Limpiar y re-test
./gradlew clean test
```

---

## Referencias

- [Testcontainers Documentation](https://www.testcontainers.org/)
- [MockWebServer (OkHttp)](https://github.com/square/okhttp/tree/master/mockwebserver)
- [JUnit 5 User Guide](https://junit.org/junit5/docs/current/user-guide/)
- [AssertJ Assertions](https://assertj.github.io/doc/)


1. ADR-001: AdopciÃ³n de Virtual Threads
Un Architecture Decision Record completo que documenta:

âœ… Contexto del problema (por quÃ© se necesitaba)
âœ… Alternativas evaluadas (ThreadPool, Reactor, Virtual Threads)
âœ… DecisiÃ³n tomada con cÃ³digo real
âœ… Consecuencias (positivas y negativas)
âœ… ValidaciÃ³n con benchmarks reales
âœ… Lecciones aprendidas

Este tipo de documento es crÃ­tico en equipos senior porque:

Explica el "por quÃ©" de decisiones tÃ©cnicas
Sirve como referencia histÃ³rica
Facilita onboarding de nuevos desarrolladores

2. Estrategia de Testing Completa
GuÃ­a prÃ¡ctica que cubre:

âœ… PirÃ¡mide de testing (70% unit, 25% integration, 5% E2E)
âœ… Mocking del SII (MockWebServer - crucial para CI/CD)
âœ… Testing multi-tenant (aislamiento de datos)
âœ… Testing de IA/Tools (mock de LLMs)
âœ… Testing de eventos (async listeners)
âœ… Cobertura con Jacoco (configuraciÃ³n Gradle)

ğŸ¯ Por QuÃ© Estos Archivos Son Valiosos:
Para la IA:

ADR-001 le dice "nunca sugieras ThreadPool tradicional - ya lo evaluamos y rechazamos"
Testing Strategy le muestra exactamente cÃ³mo testear cada capa sin conectar al SII real

Para el Equipo:

DocumentaciÃ³n viva que evoluciona con el proyecto
Referencia rÃ¡pida para decisiones tÃ©cnicas
EstÃ¡ndares claros de calidad (70% cobertura mÃ­nima)

ğŸ“ DÃ³nde Ubicarlos:
docs/
â”œâ”€â”€ decisions/
â”‚   â”œâ”€â”€ ADR-001-virtual-threads.md        â† Primer archivo
â”‚   â”œâ”€â”€ ADR-002-sii-soap-integration.md   (siguiente a crear)
â”‚   â””â”€â”€ ADR-003-event-driven-arch.md      (siguiente a crear)
â”œâ”€â”€ TESTING_STRATEGY.md                    â† Segundo archivo
â”œâ”€â”€ CONTEXT.md                             (el refactorizado)
â””â”€â”€ API_CONTRACTS.md                       (por crear)



